{"ast":null,"code":"const assert = require('./assert.js');\n\nconst nodeStore = require('./nodeStore.js'); // Initial Call, checks to make sure this is not a router application which is not supported yet\n\n\nconst parser = (dom, reactDom) => {\n  if (dom._reactInternalInstance._context.router) return 'reactRouter';\n  return ReactParentTraverse(dom);\n}; // The nodestore collects all relevant information such as ids, classes of the page in an object\n\n\nconst nodeStoreController = function (node, name, address, props, state) {\n  let parent = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  nodeStore.storage.address[address] = {};\n  nodeStore.storage.address[address].state = state;\n  nodeStore.storage.address[address].props = props;\n  nodeStore.storage.address[address].name = name;\n  let classArr; // Here we seperate out logic based on the type of component we are working on\n\n  if (node.constructor.name === 'ReactDOMComponent') {\n    // Setting id for item\n    if (props.id) nodeStore.storage.id[props.id] = address; // Setting classes for item\n\n    if (props.className) {\n      classArr = props.className.split(/\\s+/);\n      classArr.forEach(newclass => {\n        if (nodeStore.storage.class[newclass]) nodeStore.storage.class[newclass].push(address);else nodeStore.storage.class[newclass] = [address];\n      });\n    } // Storing the tag of the node\n\n\n    nodeStore.storage.tag[name] ? nodeStore.storage.tag[name].push(address) : nodeStore.storage.tag[name] = [address]; // Storing the index of the item in case we need to reference it out of a group selection. \n\n    nodeStore.storage.address[address].index = nodeStore.storage.tag[name].length - 1; // This logic will cover smart components\n  } else {\n    // We store props, state, and address about the node here\n    if (nodeStore.storage.node[name]) {\n      nodeStore.storage.node[name].address.push(address);\n      nodeStore.storage.node[name].state.push(state);\n      nodeStore.storage.node[name].props.push(props);\n    } else {\n      nodeStore.storage.node[name] = {};\n      nodeStore.storage.node[name].address = [address];\n      nodeStore.storage.node[name].state = [state];\n      nodeStore.storage.node[name].props = [props];\n    } // Index of item in case we need to reference it based on a group selection\n\n\n    nodeStore.storage.address[address].index = nodeStore.storage.node[name].address.length - 1; // Some special logic based on whether or not this component is the root component or not\n    // This is for non parent nodes\n\n    if (!parent) {\n      // Setting node id\n      if (node._renderedComponent._hostNode.id) nodeStore.storage.id[node._renderedComponent._hostNode.id] = address; // Setting node classes\n\n      if (node._renderedComponent._hostNode.className) {\n        classArr = node._renderedComponent._hostNode.className.split(/\\s+/);\n        classArr.forEach(item => {\n          if (nodeStore.storage.class[item]) nodeStore.storage.class[item].push(address);else nodeStore.storage.class[item] = [address];\n        });\n      } // Logic for parent component\n\n    } else {\n      // Setting node id\n      if (node._reactInternalInstance._renderedComponent._hostContainerInfo._node.id) nodeStore.storage.id[node._reactInternalInstance._renderedComponent._hostContainerInfo._node.id] = address; // Setting node classes\n\n      if (node._reactInternalInstance._renderedComponent._hostContainerInfo._node.className) {\n        classArr = node._reactInternalInstance._renderedComponent._hostContainerInfo._node.className.split(/\\s+/);\n        classArr.forEach(item => {\n          if (nodeStore.storage.class[item]) nodeStore.storage.class[item].push(address);else nodeStore.storage.class[item] = [address];\n        });\n      }\n    }\n  }\n};\n\nconst ReactParentTraverse = dom => {\n  // Resets the nodeStore for the new traverse\n  nodeStore.storage = {\n    address: {},\n    id: {},\n    class: {},\n    node: {},\n    tag: {}\n  }; // Create a new data object to fill with our parsed DOM. \n\n  const data = {}; // Target parent name\n\n  data.name = dom.constructor.name; // Parent is automatically a smart component, so this is set to true\n\n  data.component = true; // Setting parent props\n\n  data.props = dom.props; // Setting parent state \n\n  data.state = dom.state; // Setting parent address\n\n  data.address = [dom._reactInternalInstance._hostContainerInfo._node.id, 0]; // Setting parent id\n\n  data.id = dom._reactInternalInstance._renderedComponent._hostContainerInfo._node.id; // Setting parent class\n\n  data.class = dom._reactInternalInstance._renderedComponent._hostContainerInfo._node.className; // Add necessary data to nodeStore\n\n  nodeStoreController(dom, data.name, data.address, data.props, data.state, true); // Instantiate the children array for the parent node\n\n  data.children = []; // Setting debugId of parent node to -1. Not sure if React ever uses 0. \n\n  data.debugId = -1; // make call to another function where it will traverse through children\n\n  const children = dom._reactInternalInstance._renderedComponent._renderedChildren;\n\n  if (children) {\n    Object.values(children).forEach((child, index) => {\n      const address = data.address.slice(0);\n      address.push(index); // Here we start our recursion through the virtual DOM\n\n      if (child.constructor.name !== 'ReactDOMTextComponent') data.children.push(ReactChildTraverse(child, address));\n    });\n  } // At this point we've finished all of our recursive calls to ReactChildTraverse\n  // So we now check our asserts\n\n\n  assert.checkAssert(); // and return the data we collected\n\n  return data;\n}; // Our traversal function for every node but the root node\n\n\nconst ReactChildTraverse = (child, address) => {\n  // We declare the object we will be building, starting it with an empty children array\n  const childData = {\n    children: []\n  };\n  let children;\n  let props;\n  childData.debugId = child._debugID; // set conditional for component vs not\n\n  if (child.constructor.name === 'ReactCompositeComponentWrapper') {\n    // Parsing logic for smart React Components\n    childData.name = child._currentElement.type.name;\n    childData.component = true; // We clone the state to ensure no circular references\n\n    childData.state = cloneDeep(child._instance.state); // If props exist, make a copy of it so we can delete children out of it, otherwise it's null\n\n    let newProps = child._instance.props !== null ? Object.assign({}, child._instance.props) : null; // Delete children out of props \n\n    if (newProps.children) delete newProps.children; // Set our props to a cloned version of the props\n\n    childData.props = cloneDeep(newProps); // Get references to the node's children\n\n    children = child._renderedComponent._renderedChildren; // Set address, it's either the node's id or the address passed down to the node\n\n    childData.address = child._renderedComponent._hostNode.id ? [child._renderedComponent._hostNode.id] : address; // Set node's id \n\n    childData.id = child._renderedComponent._hostNode.id; // Set node's class\n\n    childData.class = child._renderedComponent._hostNode.className;\n  } else {\n    // Parsing logic for dumb React Components\n    // See above comments if you need to see what is happening here, same logic, different locations\n    childData.name = child._currentElement.type;\n    childData.component = false;\n    childData.state = null;\n    childData.address = child._currentElement.props.id ? [child._currentElement.props.id] : address;\n    var newProps = child._currentElement.props !== null ? Object.assign({}, child._currentElement.props) : null;\n    if (newProps.children) delete newProps.children;\n    childData.props = cloneDeep(newProps);\n    childData.id = childData.props.id;\n    childData.class = childData.props.className;\n    children = child._renderedChildren;\n  } // We add the info we've collected for our node to the nodeStore\n\n\n  nodeStoreController(child, childData.name, childData.address, childData.props, childData.state); // If we have children, set up our recursive calls\n\n  if (children) {\n    let textNodes = 0;\n    Object.values(children).forEach((child, index) => {\n      // Filter out all React Text Nodes\n      // We may want to add the text data to the parent node on a future revision\n      if (child.constructor.name === 'ReactDOMTextComponent') {\n        textNodes++;\n      } else {\n        // create new Address to pass on to children in recursive call\n        let newAddress = childData.address.slice(0); // Text nodes offset our address algorithm, so we subtract them from our address index to ensure consistency\n\n        newAddress.push(index - textNodes); // We populate our children array with the results of further recursive calls to the object's children\n\n        childData.children.push(ReactChildTraverse(child, newAddress));\n      }\n    });\n  } // Delete id and className from props as to not have confusion on the frontend\n\n\n  if (childData.props.id) delete childData.props.id;\n  if (childData.props.className) delete childData.props.className;\n  return childData;\n}; // Creates a clone of an object/array and also clones any objects/arrays that may be nested inside of it\n\n\nfunction cloneDeep(value) {\n  if (!(value instanceof Object)) return value;\n  const result = new value.constructor();\n\n  if (value.constructor === Array) {\n    value.forEach(item => result.push(cloneDeep(item)));\n  } else if (typeof value === 'function') {\n    return 'function';\n  } else {\n    for (let key in value) {\n      result[key] = cloneDeep(value[key]);\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  parser\n};","map":{"version":3,"names":["assert","require","nodeStore","parser","dom","reactDom","_reactInternalInstance","_context","router","ReactParentTraverse","nodeStoreController","node","name","address","props","state","parent","storage","classArr","constructor","id","className","split","forEach","newclass","class","push","tag","index","length","_renderedComponent","_hostNode","item","_hostContainerInfo","_node","data","component","children","debugId","_renderedChildren","Object","values","child","slice","ReactChildTraverse","checkAssert","childData","_debugID","_currentElement","type","cloneDeep","_instance","newProps","assign","textNodes","newAddress","value","result","Array","key","module","exports"],"sources":["/Users/victorcosta/Desktop/repositories/react-project/hooks-study/node_modules/react-vt/src/dom-parse.js"],"sourcesContent":["const assert = require('./assert.js');\nconst nodeStore = require('./nodeStore.js');\n\n\n// Initial Call, checks to make sure this is not a router application which is not supported yet\nconst parser = (dom, reactDom) => {\n  if (dom._reactInternalInstance._context.router) return 'reactRouter';\n  return ReactParentTraverse(dom);\n};\n\n\n// The nodestore collects all relevant information such as ids, classes of the page in an object\nconst nodeStoreController = (node, name, address, props, state, parent = false) => {\n  nodeStore.storage.address[address] = {};\n  nodeStore.storage.address[address].state = state;\n  nodeStore.storage.address[address].props = props;\n  nodeStore.storage.address[address].name = name;\n  let classArr;  \n\n  // Here we seperate out logic based on the type of component we are working on\n  if (node.constructor.name === 'ReactDOMComponent') {\n    // Setting id for item\n    if (props.id) nodeStore.storage.id[props.id] = address; \n\n    // Setting classes for item\n    if (props.className) {\n      classArr = props.className.split(/\\s+/);\n      classArr.forEach(newclass => {\n        if (nodeStore.storage.class[newclass]) nodeStore.storage.class[newclass].push(address)\n        else nodeStore.storage.class[newclass] = [address];\n      });\n    }\n    \n    // Storing the tag of the node\n    nodeStore.storage.tag[name] ? nodeStore.storage.tag[name].push(address) : nodeStore.storage.tag[name] = [address];\n    \n    // Storing the index of the item in case we need to reference it out of a group selection. \n    nodeStore.storage.address[address].index = nodeStore.storage.tag[name].length - 1; \n\n  // This logic will cover smart components\n  } else {\n \n    // We store props, state, and address about the node here\n    if (nodeStore.storage.node[name]) {\n      nodeStore.storage.node[name].address.push(address);\n      nodeStore.storage.node[name].state.push(state);\n      nodeStore.storage.node[name].props.push(props);\n\n    } else {\n      nodeStore.storage.node[name] = {};\n      nodeStore.storage.node[name].address = [address];\n      nodeStore.storage.node[name].state = [state];\n      nodeStore.storage.node[name].props = [props];\n    }\n\n    // Index of item in case we need to reference it based on a group selection\n    nodeStore.storage.address[address].index = nodeStore.storage.node[name].address.length - 1;\n\n    // Some special logic based on whether or not this component is the root component or not\n    // This is for non parent nodes\n    if (!parent) {\n      // Setting node id\n      if (node._renderedComponent._hostNode.id) nodeStore.storage.id[node._renderedComponent._hostNode.id] = address;\n      // Setting node classes\n      if (node._renderedComponent._hostNode.className) {\n        classArr = node._renderedComponent._hostNode.className.split(/\\s+/);\n        classArr.forEach(item => {\n          if (nodeStore.storage.class[item]) nodeStore.storage.class[item].push(address)\n          else nodeStore.storage.class[item] = [address];\n        });\n      }\n    // Logic for parent component\n    } else {\n      // Setting node id\n      if (node._reactInternalInstance._renderedComponent._hostContainerInfo._node.id) nodeStore.storage.id[node._reactInternalInstance._renderedComponent._hostContainerInfo._node.id] = address;\n      // Setting node classes\n      if (node._reactInternalInstance._renderedComponent._hostContainerInfo._node.className) {\n        classArr = node._reactInternalInstance._renderedComponent._hostContainerInfo._node.className.split(/\\s+/);\n        classArr.forEach(item => {\n          if (nodeStore.storage.class[item]) nodeStore.storage.class[item].push(address)\n          else nodeStore.storage.class[item] = [address];\n        });\n      }\n    } \n  }\n}\n\nconst ReactParentTraverse = (dom) => {\n  // Resets the nodeStore for the new traverse\n  nodeStore.storage = {\n  address: {},\n  id: {}, \n  class: {}, \n  node: {}, \n  tag: {} \n  }; \n\n  // Create a new data object to fill with our parsed DOM. \n  const data = {};\n\n  // Target parent name\n  data.name = dom.constructor.name;\n  // Parent is automatically a smart component, so this is set to true\n  data.component = true;\n  // Setting parent props\n  data.props = dom.props;\n  // Setting parent state \n  data.state = dom.state;\n  // Setting parent address\n  data.address = [dom._reactInternalInstance._hostContainerInfo._node.id, 0];\n  // Setting parent id\n  data.id = dom._reactInternalInstance._renderedComponent._hostContainerInfo._node.id; \n  // Setting parent class\n  data.class = dom._reactInternalInstance._renderedComponent._hostContainerInfo._node.className; \n  // Add necessary data to nodeStore\n  nodeStoreController(dom, data.name, data.address, data.props, data.state, true);\n  // Instantiate the children array for the parent node\n  data.children = [];\n\n  // Setting debugId of parent node to -1. Not sure if React ever uses 0. \n  data.debugId = -1; \n\n\n  // make call to another function where it will traverse through children\n  const children = dom._reactInternalInstance._renderedComponent._renderedChildren; \n  if (children) {\n    Object.values(children).forEach((child, index) => {\n      const address = data.address.slice(0); \n      address.push(index);\n      // Here we start our recursion through the virtual DOM\n      if (child.constructor.name !== 'ReactDOMTextComponent') data.children.push(ReactChildTraverse(child, address));\n    });\n  }\n  // At this point we've finished all of our recursive calls to ReactChildTraverse\n  // So we now check our asserts\n  assert.checkAssert();\n  // and return the data we collected\n  return data;\n};\n\n// Our traversal function for every node but the root node\nconst ReactChildTraverse = (child, address) => {\n  // We declare the object we will be building, starting it with an empty children array\n  const childData = {\n    children: [],\n  };\n  let children;\n  let props;\n  childData.debugId = child._debugID; \n  // set conditional for component vs not\n  if (child.constructor.name === 'ReactCompositeComponentWrapper') {\n    // Parsing logic for smart React Components\n    childData.name = child._currentElement.type.name;\n    childData.component = true;\n\n    // We clone the state to ensure no circular references\n    childData.state = cloneDeep(child._instance.state);\n\n    // If props exist, make a copy of it so we can delete children out of it, otherwise it's null\n    let newProps = child._instance.props !== null ? Object.assign({}, child._instance.props) : null;\n    // Delete children out of props \n    if (newProps.children) delete newProps.children; \n    // Set our props to a cloned version of the props\n    childData.props = cloneDeep(newProps);\n    // Get references to the node's children\n    children = child._renderedComponent._renderedChildren;\n    // Set address, it's either the node's id or the address passed down to the node\n    childData.address = child._renderedComponent._hostNode.id ? [child._renderedComponent._hostNode.id] : address;\n    // Set node's id \n    childData.id = child._renderedComponent._hostNode.id;\n    // Set node's class\n    childData.class = child._renderedComponent._hostNode.className; \n  } else {\n    // Parsing logic for dumb React Components\n    // See above comments if you need to see what is happening here, same logic, different locations\n    childData.name = child._currentElement.type;\n    childData.component = false;\n    childData.state = null;\n    childData.address = child._currentElement.props.id ? [child._currentElement.props.id] : address; \n    var newProps = child._currentElement.props !== null ? Object.assign({}, child._currentElement.props) : null; \n    if (newProps.children) delete newProps.children; \n    childData.props = cloneDeep(newProps);\n    childData.id = childData.props.id; \n    childData.class = childData.props.className; \n    children = child._renderedChildren;\n  }\n\n  // We add the info we've collected for our node to the nodeStore\n  nodeStoreController(child, childData.name, childData.address, childData.props, childData.state);\n\n  // If we have children, set up our recursive calls\n  if (children) {\n      let textNodes = 0; \n      Object.values(children).forEach((child, index) => {\n        // Filter out all React Text Nodes\n        // We may want to add the text data to the parent node on a future revision\n        if (child.constructor.name === 'ReactDOMTextComponent') {\n          textNodes++; \n        } else { \n          // create new Address to pass on to children in recursive call\n          let newAddress = childData.address.slice(0);\n          // Text nodes offset our address algorithm, so we subtract them from our address index to ensure consistency\n          newAddress.push(index - textNodes);\n          // We populate our children array with the results of further recursive calls to the object's children\n          childData.children.push(ReactChildTraverse(child, newAddress));\n        }\n      });\n  }\n  // Delete id and className from props as to not have confusion on the frontend\n  if (childData.props.id) delete childData.props.id; \n  if (childData.props.className) delete childData.props.className;  \n  return childData;\n};\n\n// Creates a clone of an object/array and also clones any objects/arrays that may be nested inside of it\nfunction cloneDeep(value) {\n  if (!(value instanceof Object)) return value; \n  const result = new value.constructor; \n  if (value.constructor === Array) {\n    value.forEach(item => result.push(cloneDeep(item)));\n  } else if (typeof value === 'function') {\n    return 'function'; \n  } else {\n    for (let key in value) {\n    result[key] = cloneDeep(value[key]);\n    }\n  }\n    return result;\n}\n\n\nmodule.exports = {\n  parser\n}"],"mappings":"AAAA,MAAMA,MAAM,GAAGC,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,gBAAD,CAAzB,C,CAGA;;;AACA,MAAME,MAAM,GAAG,CAACC,GAAD,EAAMC,QAAN,KAAmB;EAChC,IAAID,GAAG,CAACE,sBAAJ,CAA2BC,QAA3B,CAAoCC,MAAxC,EAAgD,OAAO,aAAP;EAChD,OAAOC,mBAAmB,CAACL,GAAD,CAA1B;AACD,CAHD,C,CAMA;;;AACA,MAAMM,mBAAmB,GAAG,UAACC,IAAD,EAAOC,IAAP,EAAaC,OAAb,EAAsBC,KAAtB,EAA6BC,KAA7B,EAAuD;EAAA,IAAnBC,MAAmB,uEAAV,KAAU;EACjFd,SAAS,CAACe,OAAV,CAAkBJ,OAAlB,CAA0BA,OAA1B,IAAqC,EAArC;EACAX,SAAS,CAACe,OAAV,CAAkBJ,OAAlB,CAA0BA,OAA1B,EAAmCE,KAAnC,GAA2CA,KAA3C;EACAb,SAAS,CAACe,OAAV,CAAkBJ,OAAlB,CAA0BA,OAA1B,EAAmCC,KAAnC,GAA2CA,KAA3C;EACAZ,SAAS,CAACe,OAAV,CAAkBJ,OAAlB,CAA0BA,OAA1B,EAAmCD,IAAnC,GAA0CA,IAA1C;EACA,IAAIM,QAAJ,CALiF,CAOjF;;EACA,IAAIP,IAAI,CAACQ,WAAL,CAAiBP,IAAjB,KAA0B,mBAA9B,EAAmD;IACjD;IACA,IAAIE,KAAK,CAACM,EAAV,EAAclB,SAAS,CAACe,OAAV,CAAkBG,EAAlB,CAAqBN,KAAK,CAACM,EAA3B,IAAiCP,OAAjC,CAFmC,CAIjD;;IACA,IAAIC,KAAK,CAACO,SAAV,EAAqB;MACnBH,QAAQ,GAAGJ,KAAK,CAACO,SAAN,CAAgBC,KAAhB,CAAsB,KAAtB,CAAX;MACAJ,QAAQ,CAACK,OAAT,CAAiBC,QAAQ,IAAI;QAC3B,IAAItB,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBD,QAAxB,CAAJ,EAAuCtB,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBD,QAAxB,EAAkCE,IAAlC,CAAuCb,OAAvC,EAAvC,KACKX,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBD,QAAxB,IAAoC,CAACX,OAAD,CAApC;MACN,CAHD;IAID,CAXgD,CAajD;;;IACAX,SAAS,CAACe,OAAV,CAAkBU,GAAlB,CAAsBf,IAAtB,IAA8BV,SAAS,CAACe,OAAV,CAAkBU,GAAlB,CAAsBf,IAAtB,EAA4Bc,IAA5B,CAAiCb,OAAjC,CAA9B,GAA0EX,SAAS,CAACe,OAAV,CAAkBU,GAAlB,CAAsBf,IAAtB,IAA8B,CAACC,OAAD,CAAxG,CAdiD,CAgBjD;;IACAX,SAAS,CAACe,OAAV,CAAkBJ,OAAlB,CAA0BA,OAA1B,EAAmCe,KAAnC,GAA2C1B,SAAS,CAACe,OAAV,CAAkBU,GAAlB,CAAsBf,IAAtB,EAA4BiB,MAA5B,GAAqC,CAAhF,CAjBiD,CAmBnD;EACC,CApBD,MAoBO;IAEL;IACA,IAAI3B,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,CAAJ,EAAkC;MAChCV,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,EAA6BC,OAA7B,CAAqCa,IAArC,CAA0Cb,OAA1C;MACAX,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,EAA6BG,KAA7B,CAAmCW,IAAnC,CAAwCX,KAAxC;MACAb,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,EAA6BE,KAA7B,CAAmCY,IAAnC,CAAwCZ,KAAxC;IAED,CALD,MAKO;MACLZ,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,IAA+B,EAA/B;MACAV,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,EAA6BC,OAA7B,GAAuC,CAACA,OAAD,CAAvC;MACAX,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,EAA6BG,KAA7B,GAAqC,CAACA,KAAD,CAArC;MACAb,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,EAA6BE,KAA7B,GAAqC,CAACA,KAAD,CAArC;IACD,CAbI,CAeL;;;IACAZ,SAAS,CAACe,OAAV,CAAkBJ,OAAlB,CAA0BA,OAA1B,EAAmCe,KAAnC,GAA2C1B,SAAS,CAACe,OAAV,CAAkBN,IAAlB,CAAuBC,IAAvB,EAA6BC,OAA7B,CAAqCgB,MAArC,GAA8C,CAAzF,CAhBK,CAkBL;IACA;;IACA,IAAI,CAACb,MAAL,EAAa;MACX;MACA,IAAIL,IAAI,CAACmB,kBAAL,CAAwBC,SAAxB,CAAkCX,EAAtC,EAA0ClB,SAAS,CAACe,OAAV,CAAkBG,EAAlB,CAAqBT,IAAI,CAACmB,kBAAL,CAAwBC,SAAxB,CAAkCX,EAAvD,IAA6DP,OAA7D,CAF/B,CAGX;;MACA,IAAIF,IAAI,CAACmB,kBAAL,CAAwBC,SAAxB,CAAkCV,SAAtC,EAAiD;QAC/CH,QAAQ,GAAGP,IAAI,CAACmB,kBAAL,CAAwBC,SAAxB,CAAkCV,SAAlC,CAA4CC,KAA5C,CAAkD,KAAlD,CAAX;QACAJ,QAAQ,CAACK,OAAT,CAAiBS,IAAI,IAAI;UACvB,IAAI9B,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBO,IAAxB,CAAJ,EAAmC9B,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBO,IAAxB,EAA8BN,IAA9B,CAAmCb,OAAnC,EAAnC,KACKX,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBO,IAAxB,IAAgC,CAACnB,OAAD,CAAhC;QACN,CAHD;MAID,CAVU,CAWb;;IACC,CAZD,MAYO;MACL;MACA,IAAIF,IAAI,CAACL,sBAAL,CAA4BwB,kBAA5B,CAA+CG,kBAA/C,CAAkEC,KAAlE,CAAwEd,EAA5E,EAAgFlB,SAAS,CAACe,OAAV,CAAkBG,EAAlB,CAAqBT,IAAI,CAACL,sBAAL,CAA4BwB,kBAA5B,CAA+CG,kBAA/C,CAAkEC,KAAlE,CAAwEd,EAA7F,IAAmGP,OAAnG,CAF3E,CAGL;;MACA,IAAIF,IAAI,CAACL,sBAAL,CAA4BwB,kBAA5B,CAA+CG,kBAA/C,CAAkEC,KAAlE,CAAwEb,SAA5E,EAAuF;QACrFH,QAAQ,GAAGP,IAAI,CAACL,sBAAL,CAA4BwB,kBAA5B,CAA+CG,kBAA/C,CAAkEC,KAAlE,CAAwEb,SAAxE,CAAkFC,KAAlF,CAAwF,KAAxF,CAAX;QACAJ,QAAQ,CAACK,OAAT,CAAiBS,IAAI,IAAI;UACvB,IAAI9B,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBO,IAAxB,CAAJ,EAAmC9B,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBO,IAAxB,EAA8BN,IAA9B,CAAmCb,OAAnC,EAAnC,KACKX,SAAS,CAACe,OAAV,CAAkBQ,KAAlB,CAAwBO,IAAxB,IAAgC,CAACnB,OAAD,CAAhC;QACN,CAHD;MAID;IACF;EACF;AACF,CAzED;;AA2EA,MAAMJ,mBAAmB,GAAIL,GAAD,IAAS;EACnC;EACAF,SAAS,CAACe,OAAV,GAAoB;IACpBJ,OAAO,EAAE,EADW;IAEpBO,EAAE,EAAE,EAFgB;IAGpBK,KAAK,EAAE,EAHa;IAIpBd,IAAI,EAAE,EAJc;IAKpBgB,GAAG,EAAE;EALe,CAApB,CAFmC,CAUnC;;EACA,MAAMQ,IAAI,GAAG,EAAb,CAXmC,CAanC;;EACAA,IAAI,CAACvB,IAAL,GAAYR,GAAG,CAACe,WAAJ,CAAgBP,IAA5B,CAdmC,CAenC;;EACAuB,IAAI,CAACC,SAAL,GAAiB,IAAjB,CAhBmC,CAiBnC;;EACAD,IAAI,CAACrB,KAAL,GAAaV,GAAG,CAACU,KAAjB,CAlBmC,CAmBnC;;EACAqB,IAAI,CAACpB,KAAL,GAAaX,GAAG,CAACW,KAAjB,CApBmC,CAqBnC;;EACAoB,IAAI,CAACtB,OAAL,GAAe,CAACT,GAAG,CAACE,sBAAJ,CAA2B2B,kBAA3B,CAA8CC,KAA9C,CAAoDd,EAArD,EAAyD,CAAzD,CAAf,CAtBmC,CAuBnC;;EACAe,IAAI,CAACf,EAAL,GAAUhB,GAAG,CAACE,sBAAJ,CAA2BwB,kBAA3B,CAA8CG,kBAA9C,CAAiEC,KAAjE,CAAuEd,EAAjF,CAxBmC,CAyBnC;;EACAe,IAAI,CAACV,KAAL,GAAarB,GAAG,CAACE,sBAAJ,CAA2BwB,kBAA3B,CAA8CG,kBAA9C,CAAiEC,KAAjE,CAAuEb,SAApF,CA1BmC,CA2BnC;;EACAX,mBAAmB,CAACN,GAAD,EAAM+B,IAAI,CAACvB,IAAX,EAAiBuB,IAAI,CAACtB,OAAtB,EAA+BsB,IAAI,CAACrB,KAApC,EAA2CqB,IAAI,CAACpB,KAAhD,EAAuD,IAAvD,CAAnB,CA5BmC,CA6BnC;;EACAoB,IAAI,CAACE,QAAL,GAAgB,EAAhB,CA9BmC,CAgCnC;;EACAF,IAAI,CAACG,OAAL,GAAe,CAAC,CAAhB,CAjCmC,CAoCnC;;EACA,MAAMD,QAAQ,GAAGjC,GAAG,CAACE,sBAAJ,CAA2BwB,kBAA3B,CAA8CS,iBAA/D;;EACA,IAAIF,QAAJ,EAAc;IACZG,MAAM,CAACC,MAAP,CAAcJ,QAAd,EAAwBd,OAAxB,CAAgC,CAACmB,KAAD,EAAQd,KAAR,KAAkB;MAChD,MAAMf,OAAO,GAAGsB,IAAI,CAACtB,OAAL,CAAa8B,KAAb,CAAmB,CAAnB,CAAhB;MACA9B,OAAO,CAACa,IAAR,CAAaE,KAAb,EAFgD,CAGhD;;MACA,IAAIc,KAAK,CAACvB,WAAN,CAAkBP,IAAlB,KAA2B,uBAA/B,EAAwDuB,IAAI,CAACE,QAAL,CAAcX,IAAd,CAAmBkB,kBAAkB,CAACF,KAAD,EAAQ7B,OAAR,CAArC;IACzD,CALD;EAMD,CA7CkC,CA8CnC;EACA;;;EACAb,MAAM,CAAC6C,WAAP,GAhDmC,CAiDnC;;EACA,OAAOV,IAAP;AACD,CAnDD,C,CAqDA;;;AACA,MAAMS,kBAAkB,GAAG,CAACF,KAAD,EAAQ7B,OAAR,KAAoB;EAC7C;EACA,MAAMiC,SAAS,GAAG;IAChBT,QAAQ,EAAE;EADM,CAAlB;EAGA,IAAIA,QAAJ;EACA,IAAIvB,KAAJ;EACAgC,SAAS,CAACR,OAAV,GAAoBI,KAAK,CAACK,QAA1B,CAP6C,CAQ7C;;EACA,IAAIL,KAAK,CAACvB,WAAN,CAAkBP,IAAlB,KAA2B,gCAA/B,EAAiE;IAC/D;IACAkC,SAAS,CAAClC,IAAV,GAAiB8B,KAAK,CAACM,eAAN,CAAsBC,IAAtB,CAA2BrC,IAA5C;IACAkC,SAAS,CAACV,SAAV,GAAsB,IAAtB,CAH+D,CAK/D;;IACAU,SAAS,CAAC/B,KAAV,GAAkBmC,SAAS,CAACR,KAAK,CAACS,SAAN,CAAgBpC,KAAjB,CAA3B,CAN+D,CAQ/D;;IACA,IAAIqC,QAAQ,GAAGV,KAAK,CAACS,SAAN,CAAgBrC,KAAhB,KAA0B,IAA1B,GAAiC0B,MAAM,CAACa,MAAP,CAAc,EAAd,EAAkBX,KAAK,CAACS,SAAN,CAAgBrC,KAAlC,CAAjC,GAA4E,IAA3F,CAT+D,CAU/D;;IACA,IAAIsC,QAAQ,CAACf,QAAb,EAAuB,OAAOe,QAAQ,CAACf,QAAhB,CAXwC,CAY/D;;IACAS,SAAS,CAAChC,KAAV,GAAkBoC,SAAS,CAACE,QAAD,CAA3B,CAb+D,CAc/D;;IACAf,QAAQ,GAAGK,KAAK,CAACZ,kBAAN,CAAyBS,iBAApC,CAf+D,CAgB/D;;IACAO,SAAS,CAACjC,OAAV,GAAoB6B,KAAK,CAACZ,kBAAN,CAAyBC,SAAzB,CAAmCX,EAAnC,GAAwC,CAACsB,KAAK,CAACZ,kBAAN,CAAyBC,SAAzB,CAAmCX,EAApC,CAAxC,GAAkFP,OAAtG,CAjB+D,CAkB/D;;IACAiC,SAAS,CAAC1B,EAAV,GAAesB,KAAK,CAACZ,kBAAN,CAAyBC,SAAzB,CAAmCX,EAAlD,CAnB+D,CAoB/D;;IACA0B,SAAS,CAACrB,KAAV,GAAkBiB,KAAK,CAACZ,kBAAN,CAAyBC,SAAzB,CAAmCV,SAArD;EACD,CAtBD,MAsBO;IACL;IACA;IACAyB,SAAS,CAAClC,IAAV,GAAiB8B,KAAK,CAACM,eAAN,CAAsBC,IAAvC;IACAH,SAAS,CAACV,SAAV,GAAsB,KAAtB;IACAU,SAAS,CAAC/B,KAAV,GAAkB,IAAlB;IACA+B,SAAS,CAACjC,OAAV,GAAoB6B,KAAK,CAACM,eAAN,CAAsBlC,KAAtB,CAA4BM,EAA5B,GAAiC,CAACsB,KAAK,CAACM,eAAN,CAAsBlC,KAAtB,CAA4BM,EAA7B,CAAjC,GAAoEP,OAAxF;IACA,IAAIuC,QAAQ,GAAGV,KAAK,CAACM,eAAN,CAAsBlC,KAAtB,KAAgC,IAAhC,GAAuC0B,MAAM,CAACa,MAAP,CAAc,EAAd,EAAkBX,KAAK,CAACM,eAAN,CAAsBlC,KAAxC,CAAvC,GAAwF,IAAvG;IACA,IAAIsC,QAAQ,CAACf,QAAb,EAAuB,OAAOe,QAAQ,CAACf,QAAhB;IACvBS,SAAS,CAAChC,KAAV,GAAkBoC,SAAS,CAACE,QAAD,CAA3B;IACAN,SAAS,CAAC1B,EAAV,GAAe0B,SAAS,CAAChC,KAAV,CAAgBM,EAA/B;IACA0B,SAAS,CAACrB,KAAV,GAAkBqB,SAAS,CAAChC,KAAV,CAAgBO,SAAlC;IACAgB,QAAQ,GAAGK,KAAK,CAACH,iBAAjB;EACD,CA5C4C,CA8C7C;;;EACA7B,mBAAmB,CAACgC,KAAD,EAAQI,SAAS,CAAClC,IAAlB,EAAwBkC,SAAS,CAACjC,OAAlC,EAA2CiC,SAAS,CAAChC,KAArD,EAA4DgC,SAAS,CAAC/B,KAAtE,CAAnB,CA/C6C,CAiD7C;;EACA,IAAIsB,QAAJ,EAAc;IACV,IAAIiB,SAAS,GAAG,CAAhB;IACAd,MAAM,CAACC,MAAP,CAAcJ,QAAd,EAAwBd,OAAxB,CAAgC,CAACmB,KAAD,EAAQd,KAAR,KAAkB;MAChD;MACA;MACA,IAAIc,KAAK,CAACvB,WAAN,CAAkBP,IAAlB,KAA2B,uBAA/B,EAAwD;QACtD0C,SAAS;MACV,CAFD,MAEO;QACL;QACA,IAAIC,UAAU,GAAGT,SAAS,CAACjC,OAAV,CAAkB8B,KAAlB,CAAwB,CAAxB,CAAjB,CAFK,CAGL;;QACAY,UAAU,CAAC7B,IAAX,CAAgBE,KAAK,GAAG0B,SAAxB,EAJK,CAKL;;QACAR,SAAS,CAACT,QAAV,CAAmBX,IAAnB,CAAwBkB,kBAAkB,CAACF,KAAD,EAAQa,UAAR,CAA1C;MACD;IACF,CAbD;EAcH,CAlE4C,CAmE7C;;;EACA,IAAIT,SAAS,CAAChC,KAAV,CAAgBM,EAApB,EAAwB,OAAO0B,SAAS,CAAChC,KAAV,CAAgBM,EAAvB;EACxB,IAAI0B,SAAS,CAAChC,KAAV,CAAgBO,SAApB,EAA+B,OAAOyB,SAAS,CAAChC,KAAV,CAAgBO,SAAvB;EAC/B,OAAOyB,SAAP;AACD,CAvED,C,CAyEA;;;AACA,SAASI,SAAT,CAAmBM,KAAnB,EAA0B;EACxB,IAAI,EAAEA,KAAK,YAAYhB,MAAnB,CAAJ,EAAgC,OAAOgB,KAAP;EAChC,MAAMC,MAAM,GAAG,IAAID,KAAK,CAACrC,WAAV,EAAf;;EACA,IAAIqC,KAAK,CAACrC,WAAN,KAAsBuC,KAA1B,EAAiC;IAC/BF,KAAK,CAACjC,OAAN,CAAcS,IAAI,IAAIyB,MAAM,CAAC/B,IAAP,CAAYwB,SAAS,CAAClB,IAAD,CAArB,CAAtB;EACD,CAFD,MAEO,IAAI,OAAOwB,KAAP,KAAiB,UAArB,EAAiC;IACtC,OAAO,UAAP;EACD,CAFM,MAEA;IACL,KAAK,IAAIG,GAAT,IAAgBH,KAAhB,EAAuB;MACvBC,MAAM,CAACE,GAAD,CAAN,GAAcT,SAAS,CAACM,KAAK,CAACG,GAAD,CAAN,CAAvB;IACC;EACF;;EACC,OAAOF,MAAP;AACH;;AAGDG,MAAM,CAACC,OAAP,GAAiB;EACf1D;AADe,CAAjB"},"metadata":{},"sourceType":"script"}