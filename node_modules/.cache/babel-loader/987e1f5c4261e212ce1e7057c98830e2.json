{"ast":null,"code":"// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\n(function (global) {\n  'use strict'; // If we're in node require encoding-indexes and attach it to the global.\n\n  if (typeof module !== \"undefined\" && module.exports && !global[\"encoding-indexes\"]) {\n    global[\"encoding-indexes\"] = require(\"./encoding-indexes.js\")[\"encoding-indexes\"];\n  } //\n  // Utilities\n  //\n\n  /**\n   * @param {number} a The number to test.\n   * @param {number} min The minimum value in the range, inclusive.\n   * @param {number} max The maximum value in the range, inclusive.\n   * @return {boolean} True if a >= min and a <= max.\n   */\n\n\n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n  /**\n   * @param {!Array.<*>} array The array to check.\n   * @param {*} item The item to look for in the array.\n   * @return {boolean} True if the item appears in the array.\n   */\n\n\n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  var floor = Math.floor;\n  /**\n   * @param {*} o\n   * @return {Object}\n   */\n\n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError('Could not convert argument to dictionary');\n  }\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {!Array.<number>} Code points.\n   */\n\n\n  function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n    // 1. Let S be the DOMString value.\n    var s = String(string); // 2. Let n be the length of S.\n\n    var n = s.length; // 3. Initialize i to 0.\n\n    var i = 0; // 4. Initialize U to be an empty sequence of Unicode characters.\n\n    var u = []; // 5. While i < n:\n\n    while (i < n) {\n      // 1. Let c be the code unit in S at index i.\n      var c = s.charCodeAt(i); // 2. Depending on the value of c:\n      // c < 0xD800 or c > 0xDFFF\n\n      if (c < 0xD800 || c > 0xDFFF) {\n        // Append to U the Unicode character with code point c.\n        u.push(c);\n      } // 0xDC00 ≤ c ≤ 0xDFFF\n      else if (0xDC00 <= c && c <= 0xDFFF) {\n        // Append to U a U+FFFD REPLACEMENT CHARACTER.\n        u.push(0xFFFD);\n      } // 0xD800 ≤ c ≤ 0xDBFF\n      else if (0xD800 <= c && c <= 0xDBFF) {\n        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n        // CHARACTER.\n        if (i === n - 1) {\n          u.push(0xFFFD);\n        } // 2. Otherwise, i < n−1:\n        else {\n          // 1. Let d be the code unit in S at index i+1.\n          var d = s.charCodeAt(i + 1); // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n\n          if (0xDC00 <= d && d <= 0xDFFF) {\n            // 1. Let a be c & 0x3FF.\n            var a = c & 0x3FF; // 2. Let b be d & 0x3FF.\n\n            var b = d & 0x3FF; // 3. Append to U the Unicode character with code point\n            // 2^16+2^10*a+b.\n\n            u.push(0x10000 + (a << 10) + b); // 4. Set i to i+1.\n\n            i += 1;\n          } // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n          // U+FFFD REPLACEMENT CHARACTER.\n          else {\n            u.push(0xFFFD);\n          }\n        }\n      } // 3. Set i to i+1.\n\n\n      i += 1;\n    } // 6. Return U.\n\n\n    return u;\n  }\n  /**\n   * @param {!Array.<number>} code_points Array of code points.\n   * @return {string} string String of UTF-16 code units.\n   */\n\n\n  function codePointsToString(code_points) {\n    var s = '';\n\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);\n      }\n    }\n\n    return s;\n  } //\n  // Implementation of Encoding specification\n  // https://encoding.spec.whatwg.org/\n  //\n  //\n  // 4. Terminology\n  //\n\n  /**\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n   * @param {number} a The number to test.\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n   */\n\n\n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n  /**\n   * An ASCII code point is a code point in the range U+0000 to\n   * U+007F, inclusive.\n   */\n\n\n  var isASCIICodePoint = isASCIIByte;\n  /**\n   * End-of-stream is a special token that signifies no more tokens\n   * are in the stream.\n   * @const\n   */\n\n  var end_of_stream = -1;\n  /**\n   * A stream represents an ordered sequence of tokens.\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n\n  function Stream(tokens) {\n    /** @type {!Array.<number>} */\n    this.tokens = [].slice.call(tokens); // Reversed as push/pop is more efficient than shift/unshift.\n\n    this.tokens.reverse();\n  }\n\n  Stream.prototype = {\n    /**\n     * @return {boolean} True if end-of-stream has been hit.\n     */\n    endOfStream: function () {\n      return !this.tokens.length;\n    },\n\n    /**\n     * When a token is read from a stream, the first token in the\n     * stream must be returned and subsequently removed, and\n     * end-of-stream must be returned otherwise.\n     *\n     * @return {number} Get the next token from the stream, or\n     * end_of_stream.\n     */\n    read: function () {\n      if (!this.tokens.length) return end_of_stream;\n      return this.tokens.pop();\n    },\n\n    /**\n     * When one or more tokens are prepended to a stream, those tokens\n     * must be inserted, in given order, before the first token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n     * stream.\n     */\n    prepend: function (token) {\n      if (Array.isArray(token)) {\n        var tokens =\n        /**@type {!Array.<number>}*/\n        token;\n\n        while (tokens.length) this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n\n    /**\n     * When one or more tokens are pushed to a stream, those tokens\n     * must be inserted, in given order, after the last token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n     * stream.\n     */\n    push: function (token) {\n      if (Array.isArray(token)) {\n        var tokens =\n        /**@type {!Array.<number>}*/\n        token;\n\n        while (tokens.length) this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  }; //\n  // 5. Encodings\n  //\n  // 5.1 Encoders and decoders\n\n  /** @const */\n\n  var finished = -1;\n  /**\n   * @param {boolean} fatal If true, decoding errors raise an exception.\n   * @param {number=} opt_code_point Override the standard fallback code point.\n   * @return {number} The code point to insert on a decoding error.\n   */\n\n  function decoderError(fatal, opt_code_point) {\n    if (fatal) throw TypeError('Decoder error');\n    return opt_code_point || 0xFFFD;\n  }\n  /**\n   * @param {number} code_point The code point that could not be encoded.\n   * @return {number} Always throws, no value is actually returned.\n   */\n\n\n  function encoderError(code_point) {\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\n  }\n  /** @interface */\n\n\n  function Decoder() {}\n\n  Decoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point, or |finished|.\n     */\n    handler: function (stream, bite) {}\n  };\n  /** @interface */\n\n  function Encoder() {}\n\n  Encoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of code points being encoded.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n     */\n    handler: function (stream, code_point) {}\n  }; // 5.2 Names and labels\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n  // https://github.com/google/closure-compiler/issues/247\n\n  /**\n   * @param {string} label The encoding label.\n   * @return {?{name:string,labels:Array.<string>}}\n   */\n\n  function getEncoding(label) {\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    label = String(label).trim().toLowerCase(); // 2. If label is an ASCII case-insensitive match for any of the\n    // labels listed in the table below, return the corresponding\n    // encoding, and failure otherwise.\n\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n\n    return null;\n  }\n  /**\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n   * @const\n   * @type {!Array.<{\n   *          heading: string,\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\n   *        }>}\n   */\n\n\n  var encodings = [{\n    \"encodings\": [{\n      \"labels\": [\"unicode-1-1-utf-8\", \"utf-8\", \"utf8\"],\n      \"name\": \"UTF-8\"\n    }],\n    \"heading\": \"The Encoding\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"866\", \"cp866\", \"csibm866\", \"ibm866\"],\n      \"name\": \"IBM866\"\n    }, {\n      \"labels\": [\"csisolatin2\", \"iso-8859-2\", \"iso-ir-101\", \"iso8859-2\", \"iso88592\", \"iso_8859-2\", \"iso_8859-2:1987\", \"l2\", \"latin2\"],\n      \"name\": \"ISO-8859-2\"\n    }, {\n      \"labels\": [\"csisolatin3\", \"iso-8859-3\", \"iso-ir-109\", \"iso8859-3\", \"iso88593\", \"iso_8859-3\", \"iso_8859-3:1988\", \"l3\", \"latin3\"],\n      \"name\": \"ISO-8859-3\"\n    }, {\n      \"labels\": [\"csisolatin4\", \"iso-8859-4\", \"iso-ir-110\", \"iso8859-4\", \"iso88594\", \"iso_8859-4\", \"iso_8859-4:1988\", \"l4\", \"latin4\"],\n      \"name\": \"ISO-8859-4\"\n    }, {\n      \"labels\": [\"csisolatincyrillic\", \"cyrillic\", \"iso-8859-5\", \"iso-ir-144\", \"iso8859-5\", \"iso88595\", \"iso_8859-5\", \"iso_8859-5:1988\"],\n      \"name\": \"ISO-8859-5\"\n    }, {\n      \"labels\": [\"arabic\", \"asmo-708\", \"csiso88596e\", \"csiso88596i\", \"csisolatinarabic\", \"ecma-114\", \"iso-8859-6\", \"iso-8859-6-e\", \"iso-8859-6-i\", \"iso-ir-127\", \"iso8859-6\", \"iso88596\", \"iso_8859-6\", \"iso_8859-6:1987\"],\n      \"name\": \"ISO-8859-6\"\n    }, {\n      \"labels\": [\"csisolatingreek\", \"ecma-118\", \"elot_928\", \"greek\", \"greek8\", \"iso-8859-7\", \"iso-ir-126\", \"iso8859-7\", \"iso88597\", \"iso_8859-7\", \"iso_8859-7:1987\", \"sun_eu_greek\"],\n      \"name\": \"ISO-8859-7\"\n    }, {\n      \"labels\": [\"csiso88598e\", \"csisolatinhebrew\", \"hebrew\", \"iso-8859-8\", \"iso-8859-8-e\", \"iso-ir-138\", \"iso8859-8\", \"iso88598\", \"iso_8859-8\", \"iso_8859-8:1988\", \"visual\"],\n      \"name\": \"ISO-8859-8\"\n    }, {\n      \"labels\": [\"csiso88598i\", \"iso-8859-8-i\", \"logical\"],\n      \"name\": \"ISO-8859-8-I\"\n    }, {\n      \"labels\": [\"csisolatin6\", \"iso-8859-10\", \"iso-ir-157\", \"iso8859-10\", \"iso885910\", \"l6\", \"latin6\"],\n      \"name\": \"ISO-8859-10\"\n    }, {\n      \"labels\": [\"iso-8859-13\", \"iso8859-13\", \"iso885913\"],\n      \"name\": \"ISO-8859-13\"\n    }, {\n      \"labels\": [\"iso-8859-14\", \"iso8859-14\", \"iso885914\"],\n      \"name\": \"ISO-8859-14\"\n    }, {\n      \"labels\": [\"csisolatin9\", \"iso-8859-15\", \"iso8859-15\", \"iso885915\", \"iso_8859-15\", \"l9\"],\n      \"name\": \"ISO-8859-15\"\n    }, {\n      \"labels\": [\"iso-8859-16\"],\n      \"name\": \"ISO-8859-16\"\n    }, {\n      \"labels\": [\"cskoi8r\", \"koi\", \"koi8\", \"koi8-r\", \"koi8_r\"],\n      \"name\": \"KOI8-R\"\n    }, {\n      \"labels\": [\"koi8-ru\", \"koi8-u\"],\n      \"name\": \"KOI8-U\"\n    }, {\n      \"labels\": [\"csmacintosh\", \"mac\", \"macintosh\", \"x-mac-roman\"],\n      \"name\": \"macintosh\"\n    }, {\n      \"labels\": [\"dos-874\", \"iso-8859-11\", \"iso8859-11\", \"iso885911\", \"tis-620\", \"windows-874\"],\n      \"name\": \"windows-874\"\n    }, {\n      \"labels\": [\"cp1250\", \"windows-1250\", \"x-cp1250\"],\n      \"name\": \"windows-1250\"\n    }, {\n      \"labels\": [\"cp1251\", \"windows-1251\", \"x-cp1251\"],\n      \"name\": \"windows-1251\"\n    }, {\n      \"labels\": [\"ansi_x3.4-1968\", \"ascii\", \"cp1252\", \"cp819\", \"csisolatin1\", \"ibm819\", \"iso-8859-1\", \"iso-ir-100\", \"iso8859-1\", \"iso88591\", \"iso_8859-1\", \"iso_8859-1:1987\", \"l1\", \"latin1\", \"us-ascii\", \"windows-1252\", \"x-cp1252\"],\n      \"name\": \"windows-1252\"\n    }, {\n      \"labels\": [\"cp1253\", \"windows-1253\", \"x-cp1253\"],\n      \"name\": \"windows-1253\"\n    }, {\n      \"labels\": [\"cp1254\", \"csisolatin5\", \"iso-8859-9\", \"iso-ir-148\", \"iso8859-9\", \"iso88599\", \"iso_8859-9\", \"iso_8859-9:1989\", \"l5\", \"latin5\", \"windows-1254\", \"x-cp1254\"],\n      \"name\": \"windows-1254\"\n    }, {\n      \"labels\": [\"cp1255\", \"windows-1255\", \"x-cp1255\"],\n      \"name\": \"windows-1255\"\n    }, {\n      \"labels\": [\"cp1256\", \"windows-1256\", \"x-cp1256\"],\n      \"name\": \"windows-1256\"\n    }, {\n      \"labels\": [\"cp1257\", \"windows-1257\", \"x-cp1257\"],\n      \"name\": \"windows-1257\"\n    }, {\n      \"labels\": [\"cp1258\", \"windows-1258\", \"x-cp1258\"],\n      \"name\": \"windows-1258\"\n    }, {\n      \"labels\": [\"x-mac-cyrillic\", \"x-mac-ukrainian\"],\n      \"name\": \"x-mac-cyrillic\"\n    }],\n    \"heading\": \"Legacy single-byte encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"chinese\", \"csgb2312\", \"csiso58gb231280\", \"gb2312\", \"gb_2312\", \"gb_2312-80\", \"gbk\", \"iso-ir-58\", \"x-gbk\"],\n      \"name\": \"GBK\"\n    }, {\n      \"labels\": [\"gb18030\"],\n      \"name\": \"gb18030\"\n    }],\n    \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"big5\", \"big5-hkscs\", \"cn-big5\", \"csbig5\", \"x-x-big5\"],\n      \"name\": \"Big5\"\n    }],\n    \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"cseucpkdfmtjapanese\", \"euc-jp\", \"x-euc-jp\"],\n      \"name\": \"EUC-JP\"\n    }, {\n      \"labels\": [\"csiso2022jp\", \"iso-2022-jp\"],\n      \"name\": \"ISO-2022-JP\"\n    }, {\n      \"labels\": [\"csshiftjis\", \"ms932\", \"ms_kanji\", \"shift-jis\", \"shift_jis\", \"sjis\", \"windows-31j\", \"x-sjis\"],\n      \"name\": \"Shift_JIS\"\n    }],\n    \"heading\": \"Legacy multi-byte Japanese encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"cseuckr\", \"csksc56011987\", \"euc-kr\", \"iso-ir-149\", \"korean\", \"ks_c_5601-1987\", \"ks_c_5601-1989\", \"ksc5601\", \"ksc_5601\", \"windows-949\"],\n      \"name\": \"EUC-KR\"\n    }],\n    \"heading\": \"Legacy multi-byte Korean encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"csiso2022kr\", \"hz-gb-2312\", \"iso-2022-cn\", \"iso-2022-cn-ext\", \"iso-2022-kr\"],\n      \"name\": \"replacement\"\n    }, {\n      \"labels\": [\"utf-16be\"],\n      \"name\": \"UTF-16BE\"\n    }, {\n      \"labels\": [\"utf-16\", \"utf-16le\"],\n      \"name\": \"UTF-16LE\"\n    }, {\n      \"labels\": [\"x-user-defined\"],\n      \"name\": \"x-user-defined\"\n    }],\n    \"heading\": \"Legacy miscellaneous encodings\"\n  }]; // Label to encoding registry.\n\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\n\n  var label_to_encoding = {};\n  encodings.forEach(function (category) {\n    category.encodings.forEach(function (encoding) {\n      encoding.labels.forEach(function (label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  }); // Registry of of encoder/decoder factories, by encoding name.\n\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\n\n  var encoders = {};\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\n\n  var decoders = {}; //\n  // 6. Indexes\n  //\n\n  /**\n   * @param {number} pointer The |pointer| to search for.\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in |index|.\n   */\n\n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n  /**\n   * @param {number} code_point The |code point| to search for.\n   * @param {!Array.<?number>} index The |index| to search within.\n   * @return {?number} The first pointer corresponding to |code point| in\n   *     |index|, or null if |code point| is not in |index|.\n   */\n\n\n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n  /**\n   * @param {string} name Name of the index.\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\n   *  */\n\n\n  function index(name) {\n    if (!('encoding-indexes' in global)) {\n      throw Error(\"Indexes missing.\" + \" Did you forget to include encoding-indexes.js first?\");\n    }\n\n    return global['encoding-indexes'][name];\n  }\n  /**\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the gb18030 index.\n   */\n\n\n  function indexGB18030RangesCodePointFor(pointer) {\n    // 1. If pointer is greater than 39419 and less than 189000, or\n    // pointer is greater than 1237575, return null.\n    if (pointer > 39419 && pointer < 189000 || pointer > 1237575) return null; // 2. If pointer is 7457, return code point U+E7C7.\n\n    if (pointer === 7457) return 0xE7C7; // 3. Let offset be the last pointer in index gb18030 ranges that\n    // is equal to or less than pointer and let code point offset be\n    // its corresponding code point.\n\n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    } // 4. Return a code point whose value is code point offset +\n    // pointer − offset.\n\n\n    return code_point_offset + pointer - offset;\n  }\n  /**\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\n   * @return {number} The first pointer corresponding to |code point| in the\n   *     gb18030 index.\n   */\n\n\n  function indexGB18030RangesPointerFor(code_point) {\n    // 1. If code point is U+E7C7, return pointer 7457.\n    if (code_point === 0xE7C7) return 7457; // 2. Let offset be the last code point in index gb18030 ranges\n    // that is equal to or less than code point and let pointer offset\n    // be its corresponding pointer.\n\n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    } // 3. Return a pointer whose value is pointer offset + code point\n    // − offset.\n\n\n    return pointer_offset + code_point - offset;\n  }\n  /**\n   * @param {number} code_point The |code_point| to search for in the Shift_JIS\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the Shift_JIS index.\n   */\n\n\n  function indexShiftJISPointerFor(code_point) {\n    // 1. Let index be index jis0208 excluding all entries whose\n    // pointer is in the range 8272 to 8835, inclusive.\n    shift_jis_index = shift_jis_index || index('jis0208').map(function (code_point, pointer) {\n      return inRange(pointer, 8272, 8835) ? null : code_point;\n    });\n    var index_ = shift_jis_index; // 2. Return the index pointer for code point in index.\n\n    return index_.indexOf(code_point);\n  }\n\n  var shift_jis_index;\n  /**\n   * @param {number} code_point The |code_point| to search for in the big5\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the big5 index.\n   */\n\n  function indexBig5PointerFor(code_point) {\n    // 1. Let index be index Big5 excluding all entries whose pointer\n    big5_index_no_hkscs = big5_index_no_hkscs || index('big5').map(function (code_point, pointer) {\n      return pointer < (0xA1 - 0x81) * 157 ? null : code_point;\n    });\n    var index_ = big5_index_no_hkscs; // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n    // U+5345, return the last pointer corresponding to code point in\n    // index.\n\n    if (code_point === 0x2550 || code_point === 0x255E || code_point === 0x2561 || code_point === 0x256A || code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    } // 3. Return the index pointer for code point in index.\n\n\n    return indexPointerFor(code_point, index_);\n  }\n\n  var big5_index_no_hkscs; //\n  // 8. API\n  //\n\n  /** @const */\n\n  var DEFAULT_ENCODING = 'utf-8'; // 8.1 Interface TextDecoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding;\n   *     defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n\n  function TextDecoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextDecoder)) throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options); // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n\n    this._decoder = null;\n    /** @private @type {boolean} */\n\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n\n    this._BOMseen = false;\n    /** @private @type {string} */\n\n    this._error_mode = 'replacement';\n    /** @private @type {boolean} */\n\n    this._do_not_flush = false; // 1. Let encoding be the result of getting an encoding from\n    // label.\n\n    var encoding = getEncoding(label); // 2. If encoding is failure or replacement, throw a RangeError.\n\n    if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);\n\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n    } // 3. Let dec be a new TextDecoder object.\n\n\n    var dec = this; // 4. Set dec's encoding to encoding.\n\n    dec._encoding = encoding; // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n\n    if (Boolean(options['fatal'])) dec._error_mode = 'fatal'; // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n\n    if (Boolean(options['ignoreBOM'])) dec._ignoreBOM = true; // For pre-ES5 runtimes:\n\n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === 'fatal';\n      this.ignoreBOM = dec._ignoreBOM;\n    } // 7. Return dec.\n\n\n    return dec;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._encoding.name.toLowerCase();\n      }\n    }); // The fatal attribute's getter must return true if error mode\n    // is fatal, and false otherwise.\n\n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._error_mode === 'fatal';\n      }\n    }); // The ignoreBOM attribute's getter must return true if ignore\n    // BOM flag is set, and false otherwise.\n\n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._ignoreBOM;\n      }\n    });\n  }\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n\n\n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input && input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options); // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'\n      });\n      this._BOMseen = false;\n    } // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n\n\n    this._do_not_flush = Boolean(options['stream']); // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n\n    var input_stream = new Stream(bytes); // 4. Let output be a new stream.\n\n    var output = [];\n    /** @type {?(number|!Array.<number>)} */\n\n    var result; // 5. While true:\n\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      var token = input_stream.read(); // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n\n      if (token === end_of_stream) break; // 3. Otherwise, run these subsubsteps:\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n\n      result = this._decoder.handler(input_stream, token); // 2. If result is finished, return output, serialized.\n\n      if (result === finished) break;\n\n      if (result !== null) {\n        if (Array.isArray(result)) output.push.apply(output,\n        /**@type {!Array.<number>}*/\n        result);else output.push(result);\n      } // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n      // 4. Otherwise, do nothing.\n\n    } // TODO: Align with spec algorithm.\n\n\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished) break;\n        if (result === null) continue;\n        if (Array.isArray(result)) output.push.apply(output,\n        /**@type {!Array.<number>}*/\n        result);else output.push(result);\n      } while (!input_stream.endOfStream());\n\n      this._decoder = null;\n    } // A TextDecoder object also has an associated serialize stream\n    // algorithm...\n\n    /**\n     * @param {!Array.<number>} stream\n     * @return {string}\n     * @this {TextDecoder}\n     */\n\n\n    function serializeStream(stream) {\n      // 1. Let token be the result of reading from stream.\n      // (Done in-place on array, rather than as a stream)\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          // 1. If token is U+FEFF, set BOM seen flag.\n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to stream.\n          this._BOMseen = true;\n        } else {// 3. Otherwise, if token is not end-of-stream, append token\n          // to output.\n          // (no-op)\n        }\n      } // 4. Otherwise, return output.\n\n\n      return codePointsToString(stream);\n    }\n\n    return serializeStream.call(this, output);\n  }; // 8.2 Interface TextEncoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} options NONSTANDARD.\n   */\n\n\n  function TextEncoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextEncoder)) throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    options = ToDictionary(options); // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n\n    this._encoding = null;\n    /** @private @type {?Encoder} */\n\n    this._encoder = null; // Non-standard\n\n    /** @private @type {boolean} */\n\n    this._do_not_flush = false;\n    /** @private @type {string} */\n\n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement'; // 1. Let enc be a new TextEncoder object.\n\n    var enc = this; // 2. Set enc's encoding to UTF-8's encoder.\n\n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);\n\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n      }\n\n      enc._encoding = encoding;\n    } else {\n      // Standard behavior.\n      enc._encoding = getEncoding('utf-8');\n\n      if (label !== undefined && 'console' in global) {\n        console.warn('TextEncoder constructor called with encoding label, ' + 'which is ignored.');\n      }\n    } // For pre-ES5 runtimes:\n\n\n    if (!Object.defineProperty) this.encoding = enc._encoding.name.toLowerCase(); // 3. Return enc.\n\n    return enc;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\n      /** @this {TextEncoder} */\n      get: function () {\n        return this._encoding.name.toLowerCase();\n      }\n    });\n  }\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n\n\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string === undefined ? '' : String(opt_string);\n    options = ToDictionary(options); // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n\n    if (!this._do_not_flush) this._encoder = encoders[this._encoding.name]({\n      fatal: this._fatal === 'fatal'\n    });\n    this._do_not_flush = Boolean(options['stream']); // 1. Convert input to a stream.\n\n    var input = new Stream(stringToCodePoints(opt_string)); // 2. Let output be a new stream\n\n    var output = [];\n    /** @type {?(number|!Array.<number>)} */\n\n    var result; // 3. While true, run these substeps:\n\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read();\n      if (token === end_of_stream) break; // 2. Let result be the result of processing token for encoder,\n      // input, output.\n\n      result = this._encoder.handler(input, token);\n      if (result === finished) break;\n      if (Array.isArray(result)) output.push.apply(output,\n      /**@type {!Array.<number>}*/\n      result);else output.push(result);\n    } // TODO: Align with spec algorithm.\n\n\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished) break;\n        if (Array.isArray(result)) output.push.apply(output,\n        /**@type {!Array.<number>}*/\n        result);else output.push(result);\n      }\n\n      this._encoder = null;\n    } // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n\n\n    return new Uint8Array(output);\n  }; //\n  // 9. The encoding\n  //\n  // 9.1 utf-8\n  // 9.1.1 utf-8 decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function UTF8Decoder(options) {\n    var fatal = options.fatal; // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n\n    var\n    /** @type {number} */\n    utf8_code_point = 0,\n\n    /** @type {number} */\n    utf8_bytes_seen = 0,\n\n    /** @type {number} */\n    utf8_bytes_needed = 0,\n\n    /** @type {number} */\n    utf8_lower_boundary = 0x80,\n\n    /** @type {number} */\n    utf8_upper_boundary = 0xBF;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream, return finished.\n\n\n      if (bite === end_of_stream) return finished; // 3. If utf-8 bytes needed is 0, based on byte:\n\n      if (utf8_bytes_needed === 0) {\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        } // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1; // 2. Set UTF-8 code point to byte & 0x1F.\n\n          utf8_code_point = bite & 0x1F;\n        } // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0) utf8_lower_boundary = 0xA0; // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n\n          if (bite === 0xED) utf8_upper_boundary = 0x9F; // 3. Set utf-8 bytes needed to 2.\n\n          utf8_bytes_needed = 2; // 4. Set UTF-8 code point to byte & 0xF.\n\n          utf8_code_point = bite & 0xF;\n        } // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0) utf8_lower_boundary = 0x90; // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n\n          if (bite === 0xF4) utf8_upper_boundary = 0x8F; // 3. Set utf-8 bytes needed to 3.\n\n          utf8_bytes_needed = 3; // 4. Set UTF-8 code point to byte & 0x7.\n\n          utf8_code_point = bite & 0x7;\n        } // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal);\n        } // Return continue.\n\n\n        return null;\n      } // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n\n\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF; // 2. Prepend byte to stream.\n\n        stream.prepend(bite); // 3. Return error.\n\n        return decoderError(fatal);\n      } // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n\n\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF; // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n\n      utf8_code_point = utf8_code_point << 6 | bite & 0x3F; // 7. Increase utf-8 bytes seen by one.\n\n      utf8_bytes_seen += 1; // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n\n      if (utf8_bytes_seen !== utf8_bytes_needed) return null; // 9. Let code point be utf-8 code point.\n\n      var code_point = utf8_code_point; // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0; // 11. Return a code point whose value is code point.\n\n      return code_point;\n    };\n  } // 9.1.2 utf-8 encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. Set count and offset based on the range code point is in:\n\n      var count, offset; // U+0080 to U+07FF, inclusive:\n\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      } // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2;\n        offset = 0xE0;\n      } // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3;\n        offset = 0xF0;\n      } // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n\n\n      var bytes = [(code_point >> 6 * count) + offset]; // 5. Run these substeps while count is greater than 0:\n\n      while (count > 0) {\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> 6 * (count - 1); // 2. Append to bytes 0x80 | (temp & 0x3F).\n\n        bytes.push(0x80 | temp & 0x3F); // 3. Decrease count by one.\n\n        count -= 1;\n      } // 6. Return bytes bytes, in order.\n\n\n      return bytes;\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['UTF-8'] = function (options) {\n    return new UTF8Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['UTF-8'] = function (options) {\n    return new UTF8Decoder(options);\n  }; //\n  // 10. Legacy single-byte encodings\n  //\n  // 10.1 single-byte decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream) return finished; // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n      if (isASCIIByte(bite)) return bite; // 3. Let code point be the index code point for byte − 0x80 in\n      // index single-byte.\n\n      var code_point = index[bite - 0x80]; // 4. If code point is null, return error.\n\n      if (code_point === null) return decoderError(fatal); // 5. Return a code point whose value is code point.\n\n      return code_point;\n    };\n  } // 10.2 single-byte encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {!Array.<?number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. Let pointer be the index pointer for code point in index\n      // single-byte.\n\n      var pointer = indexPointerFor(code_point, index); // 4. If pointer is null, return error with code point.\n\n      if (pointer === null) encoderError(code_point); // 5. Return a byte whose value is pointer + 0x80.\n\n      return pointer + 0x80;\n    };\n  }\n\n  (function () {\n    if (!('encoding-indexes' in global)) return;\n    encodings.forEach(function (category) {\n      if (category.heading !== 'Legacy single-byte encodings') return;\n      category.encodings.forEach(function (encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n        /** @param {{fatal: boolean}} options */\n\n        decoders[name] = function (options) {\n          return new SingleByteDecoder(idx, options);\n        };\n        /** @param {{fatal: boolean}} options */\n\n\n        encoders[name] = function (options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  })(); //\n  // 11. Legacy multi-byte Chinese (simplified) encodings\n  //\n  // 11.1 gbk\n  // 11.1.1 gbk decoder\n  // gbk's decoder is gb18030's decoder.\n\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['GBK'] = function (options) {\n    return new GB18030Decoder(options);\n  }; // 11.1.2 gbk encoder\n  // gbk's encoder is gb18030's encoder with its gbk flag set.\n\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['GBK'] = function (options) {\n    return new GB18030Encoder(options, true);\n  }; // 11.2 gb18030\n  // 11.2.1 gb18030 decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function GB18030Decoder(options) {\n    var fatal = options.fatal; // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n\n    var\n    /** @type {number} */\n    gb18030_first = 0x00,\n\n    /** @type {number} */\n    gb18030_second = 0x00,\n\n    /** @type {number} */\n    gb18030_third = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\n      // second, and gb18030 third are 0x00, return finished.\n      if (bite === end_of_stream && gb18030_first === 0x00 && gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      } // 2. If byte is end-of-stream, and gb18030 first, gb18030\n      // second, or gb18030 third is not 0x00, set gb18030 first,\n      // gb18030 second, and gb18030 third to 0x00, and return error.\n\n\n      if (bite === end_of_stream && (gb18030_first !== 0x00 || gb18030_second !== 0x00 || gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n\n      var code_point; // 3. If gb18030 third is not 0x00, run these substeps:\n\n      if (gb18030_third !== 0x00) {\n        // 1. Let code point be null.\n        code_point = null; // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n        // code point to the index gb18030 ranges code point for\n        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n\n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor((((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 + gb18030_third - 0x81) * 10 + bite - 0x30);\n        } // 3. Let buffer be a byte sequence consisting of gb18030\n        // second, gb18030 third, and byte, in order.\n\n\n        var buffer = [gb18030_second, gb18030_third, bite]; // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n        // 0x00.\n\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00; // 5. If code point is null, prepend buffer to stream and\n        // return error.\n\n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        } // 6. Return a code point whose value is code point.\n\n\n        return code_point;\n      } // 4. If gb18030 second is not 0x00, run these substeps:\n\n\n      if (gb18030_second !== 0x00) {\n        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n        // gb18030 third to byte and return continue.\n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        } // 2. Prepend gb18030 second followed by byte to stream, set\n        // gb18030 first and gb18030 second to 0x00, and return error.\n\n\n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      } // 5. If gb18030 first is not 0x00, run these substeps:\n\n\n      if (gb18030_first !== 0x00) {\n        // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n        // gb18030 second to byte and return continue.\n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        } // 2. Let lead be gb18030 first, let pointer be null, and set\n        // gb18030 first to 0x00.\n\n\n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00; // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n        // otherwise.\n\n        var offset = bite < 0x7F ? 0x40 : 0x41; // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n        // (byte − offset).\n\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - offset); // 5. Let code point be null if pointer is null and the index\n        // code point for pointer in index gb18030 otherwise.\n\n        code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030')); // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite); // 7. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 8. Return a code point whose value is code point.\n\n        return code_point;\n      } // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n\n      if (isASCIIByte(bite)) return bite; // 7. If byte is 0x80, return code point U+20AC.\n\n      if (bite === 0x80) return 0x20AC; // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 first to byte and return continue.\n\n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      } // 9. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 11.2.2 gb18030 encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   * @param {boolean=} gbk_flag\n   */\n\n\n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal; // gb18030's decoder has an associated gbk flag (initially unset).\n\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. If code point is U+E5E5, return error with code point.\n\n      if (code_point === 0xE5E5) return encoderError(code_point); // 4. If the gbk flag is set and code point is U+20AC, return\n      // byte 0x80.\n\n      if (gbk_flag && code_point === 0x20AC) return 0x80; // 5. Let pointer be the index pointer for code point in index\n      // gb18030.\n\n      var pointer = indexPointerFor(code_point, index('gb18030')); // 6. If pointer is not null, run these substeps:\n\n      if (pointer !== null) {\n        // 1. Let lead be floor(pointer / 190) + 0x81.\n        var lead = floor(pointer / 190) + 0x81; // 2. Let trail be pointer % 190.\n\n        var trail = pointer % 190; // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n\n        var offset = trail < 0x3F ? 0x40 : 0x41; // 4. Return two bytes whose values are lead and trail + offset.\n\n        return [lead, trail + offset];\n      } // 7. If gbk flag is set, return error with code point.\n\n\n      if (gbk_flag) return encoderError(code_point); // 8. Set pointer to the index gb18030 ranges pointer for code\n      // point.\n\n      pointer = indexGB18030RangesPointerFor(code_point); // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n\n      var byte1 = floor(pointer / 10 / 126 / 10); // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n\n      pointer = pointer - byte1 * 10 * 126 * 10; // 11. Let byte2 be floor(pointer / 10 / 126).\n\n      var byte2 = floor(pointer / 10 / 126); // 12. Set pointer to pointer − byte2 × 10 × 126.\n\n      pointer = pointer - byte2 * 10 * 126; // 13. Let byte3 be floor(pointer / 10).\n\n      var byte3 = floor(pointer / 10); // 14. Let byte4 be pointer − byte3 × 10.\n\n      var byte4 = pointer - byte3 * 10; // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\n\n      return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['gb18030'] = function (options) {\n    return new GB18030Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['gb18030'] = function (options) {\n    return new GB18030Decoder(options);\n  }; //\n  // 12. Legacy multi-byte Chinese (traditional) encodings\n  //\n  // 12.1 Big5\n  // 12.1.1 Big5 decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function Big5Decoder(options) {\n    var fatal = options.fatal; // Big5's decoder has an associated Big5 lead (initially 0x00).\n\n    var\n    /** @type {number} */\n    Big5_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n      // Big5 lead to 0x00 and return error.\n      if (bite === end_of_stream && Big5_lead !== 0x00) {\n        Big5_lead = 0x00;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n      // finished.\n\n\n      if (bite === end_of_stream && Big5_lead === 0x00) return finished; // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n      // pointer be null, set Big5 lead to 0x00, and then run these\n      // substeps:\n\n      if (Big5_lead !== 0x00) {\n        var lead = Big5_lead;\n        var pointer = null;\n        Big5_lead = 0x00; // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n        // otherwise.\n\n        var offset = bite < 0x7F ? 0x40 : 0x62; // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n        // (byte − offset).\n\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE)) pointer = (lead - 0x81) * 157 + (bite - offset); // 3. If there is a row in the table below whose first column\n        // is pointer, return the two code points listed in its second\n        // column\n        // Pointer | Code points\n        // --------+--------------\n        // 1133    | U+00CA U+0304\n        // 1135    | U+00CA U+030C\n        // 1164    | U+00EA U+0304\n        // 1166    | U+00EA U+030C\n\n        switch (pointer) {\n          case 1133:\n            return [0x00CA, 0x0304];\n\n          case 1135:\n            return [0x00CA, 0x030C];\n\n          case 1164:\n            return [0x00EA, 0x0304];\n\n          case 1166:\n            return [0x00EA, 0x030C];\n        } // 4. Let code point be null if pointer is null and the index\n        // code point for pointer in index Big5 otherwise.\n\n\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5')); // 5. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite); // 6. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 7. Return a code point whose value is code point.\n\n        return code_point;\n      } // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n\n      if (isASCIIByte(bite)) return bite; // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n      // lead to byte and return continue.\n\n      if (inRange(bite, 0x81, 0xFE)) {\n        Big5_lead = bite;\n        return null;\n      } // 6. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 12.1.2 Big5 encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. Let pointer be the index Big5 pointer for code point.\n\n      var pointer = indexBig5PointerFor(code_point); // 4. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 5. Let lead be floor(pointer / 157) + 0x81.\n\n      var lead = floor(pointer / 157) + 0x81; // 6. If lead is less than 0xA1, return error with code point.\n\n      if (lead < 0xA1) return encoderError(code_point); // 7. Let trail be pointer % 157.\n\n      var trail = pointer % 157; // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n\n      var offset = trail < 0x3F ? 0x40 : 0x62; // Return two bytes whose values are lead and trail + offset.\n\n      return [lead, trail + offset];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['Big5'] = function (options) {\n    return new Big5Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['Big5'] = function (options) {\n    return new Big5Decoder(options);\n  }; //\n  // 13. Legacy multi-byte Japanese encodings\n  //\n  // 13.1 euc-jp\n  // 13.1.1 euc-jp decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function EUCJPDecoder(options) {\n    var fatal = options.fatal; // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n\n    var\n    /** @type {boolean} */\n    eucjp_jis0212_flag = false,\n\n    /** @type {number} */\n    eucjp_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n      // euc-jp lead to 0x00, and return error.\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n      // finished.\n\n\n      if (bite === end_of_stream && eucjp_lead === 0x00) return finished; // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n      // point whose value is 0xFF61 − 0xA1 + byte.\n\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 - 0xA1 + bite;\n      } // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n      // to byte, and return continue.\n\n\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      } // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n      // euc-jp lead to 0x00, and run these substeps:\n\n\n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00; // 1. Let code point be null.\n\n        var code_point = null; // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n        // inclusive, set code point to the index code point for (lead\n        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n        // jis0212 flag is unset and in index jis0212 otherwise.\n\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor((lead - 0xA1) * 94 + (bite - 0xA1), index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n        } // 3. Unset the euc-jp jis0212 flag.\n\n\n        eucjp_jis0212_flag = false; // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n        // prepend byte to stream.\n\n        if (!inRange(bite, 0xA1, 0xFE)) stream.prepend(bite); // 5. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 6. Return a code point whose value is code point.\n\n        return code_point;\n      } // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n\n      if (isASCIIByte(bite)) return bite; // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n      // inclusive, set euc-jp lead to byte and return continue.\n\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      } // 8. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 13.1.2 euc-jp encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. If code point is U+00A5, return byte 0x5C.\n\n      if (code_point === 0x00A5) return 0x5C; // 4. If code point is U+203E, return byte 0x7E.\n\n      if (code_point === 0x203E) return 0x7E; // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return two bytes whose values are 0x8E and code point −\n      // 0xFF61 + 0xA1.\n\n      if (inRange(code_point, 0xFF61, 0xFF9F)) return [0x8E, code_point - 0xFF61 + 0xA1]; // 6. If code point is U+2212, set it to U+FF0D.\n\n      if (code_point === 0x2212) code_point = 0xFF0D; // 7. Let pointer be the index pointer for code point in index\n      // jis0208.\n\n      var pointer = indexPointerFor(code_point, index('jis0208')); // 8. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 9. Let lead be floor(pointer / 94) + 0xA1.\n\n      var lead = floor(pointer / 94) + 0xA1; // 10. Let trail be pointer % 94 + 0xA1.\n\n      var trail = pointer % 94 + 0xA1; // 11. Return two bytes whose values are lead and trail.\n\n      return [lead, trail];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['EUC-JP'] = function (options) {\n    return new EUCJPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['EUC-JP'] = function (options) {\n    return new EUCJPDecoder(options);\n  }; // 13.2 iso-2022-jp\n  // 13.2.1 iso-2022-jp decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n    /** @enum */\n\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    }; // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n\n    var\n    /** @type {number} */\n    iso2022jp_decoder_state = states.ASCII,\n\n    /** @type {number} */\n    iso2022jp_decoder_output_state = states.ASCII,\n\n    /** @type {number} */\n    iso2022jp_lead = 0x00,\n\n    /** @type {boolean} */\n    iso2022jp_output_flag = false;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // switching on iso-2022-jp decoder state:\n      switch (iso2022jp_decoder_state) {\n        default:\n        case states.ASCII:\n          // ASCII\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          } // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n\n\n          if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is byte.\n            iso2022jp_output_flag = false;\n            return bite;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          } // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n\n\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n\n        case states.Roman:\n          // Roman\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          } // 0x5C\n\n\n          if (bite === 0x5C) {\n            // Unset the iso-2022-jp output flag and return code point\n            // U+00A5.\n            iso2022jp_output_flag = false;\n            return 0x00A5;\n          } // 0x7E\n\n\n          if (bite === 0x7E) {\n            // Unset the iso-2022-jp output flag and return code point\n            // U+203E.\n            iso2022jp_output_flag = false;\n            return 0x203E;\n          } // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n\n\n          if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is byte.\n            iso2022jp_output_flag = false;\n            return bite;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          } // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n\n\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n\n        case states.Katakana:\n          // Katakana\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          } // 0x21 to 0x5F\n\n\n          if (inRange(bite, 0x21, 0x5F)) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is 0xFF61 − 0x21 + byte.\n            iso2022jp_output_flag = false;\n            return 0xFF61 - 0x21 + bite;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          } // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n\n\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n\n        case states.LeadByte:\n          // Lead byte\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          } // 0x21 to 0x7E\n\n\n          if (inRange(bite, 0x21, 0x7E)) {\n            // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n            // to byte, iso-2022-jp decoder state to trail byte, and\n            // return continue.\n            iso2022jp_output_flag = false;\n            iso2022jp_lead = bite;\n            iso2022jp_decoder_state = states.TrailByte;\n            return null;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          } // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n\n\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n\n        case states.TrailByte:\n          // Trail byte\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return decoderError(fatal);\n          } // 0x21 to 0x7E\n\n\n          if (inRange(bite, 0x21, 0x7E)) {\n            // 1. Set the iso-2022-jp decoder state to lead byte.\n            iso2022jp_decoder_state = states.LeadByte; // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n\n            var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21; // 3. Let code point be the index code point for pointer in\n            // index jis0208.\n\n            var code_point = indexCodePointFor(pointer, index('jis0208')); // 4. If code point is null, return error.\n\n            if (code_point === null) return decoderError(fatal); // 5. Return a code point whose value is code point.\n\n            return code_point;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Set the iso-2022-jp decoder state to lead byte, prepend\n            // byte to stream, and return error.\n            iso2022jp_decoder_state = states.LeadByte;\n            stream.prepend(bite);\n            return decoderError(fatal);\n          } // Otherwise\n          // Set iso-2022-jp decoder state to lead byte and return\n          // error.\n\n\n          iso2022jp_decoder_state = states.LeadByte;\n          return decoderError(fatal);\n\n        case states.EscapeStart:\n          // Escape start\n          // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n          // byte, iso-2022-jp decoder state to escape, and return\n          // continue.\n          if (bite === 0x24 || bite === 0x28) {\n            iso2022jp_lead = bite;\n            iso2022jp_decoder_state = states.Escape;\n            return null;\n          } // 2. Prepend byte to stream.\n\n\n          stream.prepend(bite); // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n          // decoder state to iso-2022-jp decoder output state, and\n          // return error.\n\n          iso2022jp_output_flag = false;\n          iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n          return decoderError(fatal);\n\n        case states.Escape:\n          // Escape\n          // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n          // 0x00.\n          var lead = iso2022jp_lead;\n          iso2022jp_lead = 0x00; // 2. Let state be null.\n\n          var state = null; // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n\n          if (lead === 0x28 && bite === 0x42) state = states.ASCII; // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n\n          if (lead === 0x28 && bite === 0x4A) state = states.Roman; // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n\n          if (lead === 0x28 && bite === 0x49) state = states.Katakana; // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n          // state to lead byte.\n\n          if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = states.LeadByte; // 7. If state is non-null, run these substeps:\n\n          if (state !== null) {\n            // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n            // output state to states.\n            iso2022jp_decoder_state = iso2022jp_decoder_state = state; // 2. Let output flag be the iso-2022-jp output flag.\n\n            var output_flag = iso2022jp_output_flag; // 3. Set the iso-2022-jp output flag.\n\n            iso2022jp_output_flag = true; // 4. Return continue, if output flag is unset, and error\n            // otherwise.\n\n            return !output_flag ? null : decoderError(fatal);\n          } // 8. Prepend lead and byte to stream.\n\n\n          stream.prepend([lead, bite]); // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n          // decoder state to iso-2022-jp decoder output state and\n          // return error.\n\n          iso2022jp_output_flag = false;\n          iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n          return decoderError(fatal);\n      }\n    };\n  } // 13.2.2 iso-2022-jp encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal; // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n\n    /** @enum */\n\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var\n    /** @type {number} */\n    iso2022jp_state = states.ASCII;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\n      // state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      } // 2. If code point is end-of-stream and iso-2022-jp encoder\n      // state is ASCII, return finished.\n\n\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished; // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n\n      if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 0x000E || code_point === 0x000F || code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      } // 4. If iso-2022-jp encoder state is ASCII and code point is an\n      // ASCII code point, return a byte whose value is code point.\n\n\n      if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point; // 5. If iso-2022-jp encoder state is Roman and code point is an\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n      // or U+203E, run these substeps:\n\n      if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 0x005C && code_point !== 0x007E || code_point == 0x00A5 || code_point == 0x203E)) {\n        // 1. If code point is an ASCII code point, return a byte\n        // whose value is code point.\n        if (isASCIICodePoint(code_point)) return code_point; // 2. If code point is U+00A5, return byte 0x5C.\n\n        if (code_point === 0x00A5) return 0x5C; // 3. If code point is U+203E, return byte 0x7E.\n\n        if (code_point === 0x203E) return 0x7E;\n      } // 6. If code point is an ASCII code point, and iso-2022-jp\n      // encoder state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n\n\n      if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      } // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n      // encoder state is not Roman, prepend code point to stream, set\n      // iso-2022-jp encoder state to Roman, and return three bytes\n      // 0x1B 0x28 0x4A.\n\n\n      if ((code_point === 0x00A5 || code_point === 0x203E) && iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      } // 8. If code point is U+2212, set it to U+FF0D.\n\n\n      if (code_point === 0x2212) code_point = 0xFF0D; // 9. Let pointer be the index pointer for code point in index\n      // jis0208.\n\n      var pointer = indexPointerFor(code_point, index('jis0208')); // 10. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n      // point to stream, set iso-2022-jp encoder state to jis0208,\n      // and return three bytes 0x1B 0x24 0x42.\n\n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      } // 12. Let lead be floor(pointer / 94) + 0x21.\n\n\n      var lead = floor(pointer / 94) + 0x21; // 13. Let trail be pointer % 94 + 0x21.\n\n      var trail = pointer % 94 + 0x21; // 14. Return two bytes whose values are lead and trail.\n\n      return [lead, trail];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['ISO-2022-JP'] = function (options) {\n    return new ISO2022JPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['ISO-2022-JP'] = function (options) {\n    return new ISO2022JPDecoder(options);\n  }; // 13.3 Shift_JIS\n  // 13.3.1 Shift_JIS decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal; // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n\n    var\n    /** @type {number} */\n    Shift_JIS_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n      // set Shift_JIS lead to 0x00 and return error.\n      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n        Shift_JIS_lead = 0x00;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n      // return finished.\n\n\n      if (bite === end_of_stream && Shift_JIS_lead === 0x00) return finished; // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n      // let pointer be null, set Shift_JIS lead to 0x00, and then run\n      // these substeps:\n\n      if (Shift_JIS_lead !== 0x00) {\n        var lead = Shift_JIS_lead;\n        var pointer = null;\n        Shift_JIS_lead = 0x00; // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n        // otherwise.\n\n        var offset = bite < 0x7F ? 0x40 : 0x41; // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n        // 0xC1 otherwise.\n\n        var lead_offset = lead < 0xA0 ? 0x81 : 0xC1; // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n        // 188 + byte − offset.\n\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC)) pointer = (lead - lead_offset) * 188 + bite - offset; // 4. If pointer is in the range 8836 to 10715, inclusive,\n        // return a code point whose value is 0xE000 − 8836 + pointer.\n\n        if (inRange(pointer, 8836, 10715)) return 0xE000 - 8836 + pointer; // 5. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index jis0208 otherwise.\n\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208')); // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite); // 7. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 8. Return a code point whose value is code point.\n\n        return code_point;\n      } // 4. If byte is an ASCII byte or 0x80, return a code point\n      // whose value is byte.\n\n\n      if (isASCIIByte(bite) || bite === 0x80) return bite; // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n      // code point whose value is 0xFF61 − 0xA1 + byte.\n\n      if (inRange(bite, 0xA1, 0xDF)) return 0xFF61 - 0xA1 + bite; // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n      // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n      // continue.\n\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        Shift_JIS_lead = bite;\n        return null;\n      } // 7. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 13.3.2 Shift_JIS encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point or U+0080, return a\n      // byte whose value is code point.\n\n      if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point; // 3. If code point is U+00A5, return byte 0x5C.\n\n      if (code_point === 0x00A5) return 0x5C; // 4. If code point is U+203E, return byte 0x7E.\n\n      if (code_point === 0x203E) return 0x7E; // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return a byte whose value is code point − 0xFF61 + 0xA1.\n\n      if (inRange(code_point, 0xFF61, 0xFF9F)) return code_point - 0xFF61 + 0xA1; // 6. If code point is U+2212, set it to U+FF0D.\n\n      if (code_point === 0x2212) code_point = 0xFF0D; // 7. Let pointer be the index Shift_JIS pointer for code point.\n\n      var pointer = indexShiftJISPointerFor(code_point); // 8. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 9. Let lead be floor(pointer / 188).\n\n      var lead = floor(pointer / 188); // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n      // 0xC1 otherwise.\n\n      var lead_offset = lead < 0x1F ? 0x81 : 0xC1; // 11. Let trail be pointer % 188.\n\n      var trail = pointer % 188; // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n      // otherwise.\n\n      var offset = trail < 0x3F ? 0x40 : 0x41; // 13. Return two bytes whose values are lead + lead offset and\n      // trail + offset.\n\n      return [lead + lead_offset, trail + offset];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['Shift_JIS'] = function (options) {\n    return new ShiftJISEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['Shift_JIS'] = function (options) {\n    return new ShiftJISDecoder(options);\n  }; //\n  // 14. Legacy multi-byte Korean encodings\n  //\n  // 14.1 euc-kr\n  // 14.1.1 euc-kr decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function EUCKRDecoder(options) {\n    var fatal = options.fatal; // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n\n    var\n    /** @type {number} */\n    euckr_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n      // euc-kr lead to 0x00 and return error.\n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n      // finished.\n\n\n      if (bite === end_of_stream && euckr_lead === 0) return finished; // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n      // pointer be null, set euc-kr lead to 0x00, and then run these\n      // substeps:\n\n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00; // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n        // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n\n        if (inRange(bite, 0x41, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - 0x41); // 2. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index euc-kr otherwise.\n\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr')); // 3. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n\n        if (pointer === null && isASCIIByte(bite)) stream.prepend(bite); // 4. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 5. Return a code point whose value is code point.\n\n        return code_point;\n      } // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n\n      if (isASCIIByte(bite)) return bite; // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // euc-kr lead to byte and return continue.\n\n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      } // 6. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 14.1.2 euc-kr encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. Let pointer be the index pointer for code point in index\n      // euc-kr.\n\n      var pointer = indexPointerFor(code_point, index('euc-kr')); // 4. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 5. Let lead be floor(pointer / 190) + 0x81.\n\n      var lead = floor(pointer / 190) + 0x81; // 6. Let trail be pointer % 190 + 0x41.\n\n      var trail = pointer % 190 + 0x41; // 7. Return two bytes whose values are lead and trail.\n\n      return [lead, trail];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['EUC-KR'] = function (options) {\n    return new EUCKREncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['EUC-KR'] = function (options) {\n    return new EUCKRDecoder(options);\n  }; //\n  // 15. Legacy miscellaneous encodings\n  //\n  // 15.1 replacement\n  // Not needed - API throws RangeError\n  // 15.2 Common infrastructure for utf-16be and utf-16le\n\n  /**\n   * @param {number} code_unit\n   * @param {boolean} utf16be\n   * @return {!Array.<number>} bytes\n   */\n\n\n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    // 1. Let byte1 be code unit >> 8.\n    var byte1 = code_unit >> 8; // 2. Let byte2 be code unit & 0x00FF.\n\n    var byte2 = code_unit & 0x00FF; // 3. Then return the bytes in order:\n    // utf-16be flag is set: byte1, then byte2.\n\n    if (utf16be) return [byte1, byte2]; // utf-16be flag is unset: byte2, then byte1.\n\n    return [byte2, byte1];\n  } // 15.2.1 shared utf-16 decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var\n    /** @type {?number} */\n    utf16_lead_byte = null,\n\n    /** @type {?number} */\n    utf16_lead_surrogate = null;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\n      // utf-16 lead surrogate to null, and return error.\n      if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n      // lead surrogate are null, return finished.\n\n\n      if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {\n        return finished;\n      } // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n      // and return continue.\n\n\n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      } // 4. Let code unit be the result of:\n\n\n      var code_unit;\n\n      if (utf16_be) {\n        // utf-16be decoder flag is set\n        //   (utf-16 lead byte << 8) + byte.\n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        // utf-16be decoder flag is unset\n        //   (byte << 8) + utf-16 lead byte.\n        code_unit = (bite << 8) + utf16_lead_byte;\n      } // Then set utf-16 lead byte to null.\n\n\n      utf16_lead_byte = null; // 5. If utf-16 lead surrogate is not null, let lead surrogate\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n      // and then run these substeps:\n\n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null; // 1. If code unit is in the range U+DC00 to U+DFFF,\n        // inclusive, return a code point whose value is 0x10000 +\n        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 + (code_unit - 0xDC00);\n        } // 2. Prepend the sequence resulting of converting code unit\n        // to bytes using utf-16be decoder flag to stream and return\n        // error.\n\n\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      } // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n      // set utf-16 lead surrogate to code unit and return continue.\n\n\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      } // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n      // return error.\n\n\n      if (inRange(code_unit, 0xDC00, 0xDFFF)) return decoderError(fatal); // 8. Return code point code unit.\n\n      return code_unit;\n    };\n  } // 15.2.2 shared utf-16 encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n      // return the sequence resulting of converting code point to\n      // bytes using utf-16be encoder flag.\n\n      if (inRange(code_point, 0x0000, 0xFFFF)) return convertCodeUnitToBytes(code_point, utf16_be); // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n      // converted to bytes using utf-16be encoder flag.\n\n      var lead = convertCodeUnitToBytes((code_point - 0x10000 >> 10) + 0xD800, utf16_be); // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n      // converted to bytes using utf-16be encoder flag.\n\n      var trail = convertCodeUnitToBytes((code_point - 0x10000 & 0x3FF) + 0xDC00, utf16_be); // 5. Return a byte sequence of lead followed by trail.\n\n      return lead.concat(trail);\n    };\n  } // 15.3 utf-16be\n  // 15.3.1 utf-16be decoder\n\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['UTF-16BE'] = function (options) {\n    return new UTF16Encoder(true, options);\n  }; // 15.3.2 utf-16be encoder\n\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['UTF-16BE'] = function (options) {\n    return new UTF16Decoder(true, options);\n  }; // 15.4 utf-16le\n  // 15.4.1 utf-16le decoder\n\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['UTF-16LE'] = function (options) {\n    return new UTF16Encoder(false, options);\n  }; // 15.4.2 utf-16le encoder\n\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['UTF-16LE'] = function (options) {\n    return new UTF16Decoder(false, options);\n  }; // 15.5 x-user-defined\n  // 15.5.1 x-user-defined decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream) return finished; // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n      if (isASCIIByte(bite)) return bite; // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n\n      return 0xF780 + bite - 0x80;\n    };\n  } // 15.5.2 x-user-defined encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1.If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n      // return a byte whose value is code point − 0xF780 + 0x80.\n\n      if (inRange(code_point, 0xF780, 0xF7FF)) return code_point - 0xF780 + 0x80; // 4. Return error with code point.\n\n      return encoderError(code_point);\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['x-user-defined'] = function (options) {\n    return new XUserDefinedEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['x-user-defined'] = function (options) {\n    return new XUserDefinedDecoder(options);\n  };\n\n  if (!global['TextEncoder']) global['TextEncoder'] = TextEncoder;\n  if (!global['TextDecoder']) global['TextDecoder'] = TextDecoder;\n\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = {\n      TextEncoder: global['TextEncoder'],\n      TextDecoder: global['TextDecoder'],\n      EncodingIndexes: global[\"encoding-indexes\"]\n    };\n  } // For strict environments where `this` inside the global scope\n  // is `undefined`, take a pure object instead\n\n})(this || {});","map":{"version":3,"names":["global","module","exports","require","inRange","a","min","max","includes","array","item","indexOf","floor","Math","ToDictionary","o","undefined","Object","TypeError","stringToCodePoints","string","s","String","n","length","i","u","c","charCodeAt","push","d","b","codePointsToString","code_points","cp","fromCharCode","isASCIIByte","isASCIICodePoint","end_of_stream","Stream","tokens","slice","call","reverse","prototype","endOfStream","read","pop","prepend","token","Array","isArray","unshift","shift","finished","decoderError","fatal","opt_code_point","encoderError","code_point","Decoder","handler","stream","bite","Encoder","getEncoding","label","trim","toLowerCase","hasOwnProperty","label_to_encoding","encodings","forEach","category","encoding","labels","encoders","decoders","indexCodePointFor","pointer","index","indexPointerFor","name","Error","indexGB18030RangesCodePointFor","offset","code_point_offset","idx","entry","indexGB18030RangesPointerFor","pointer_offset","indexShiftJISPointerFor","shift_jis_index","map","index_","indexBig5PointerFor","big5_index_no_hkscs","lastIndexOf","DEFAULT_ENCODING","TextDecoder","options","_encoding","_decoder","_ignoreBOM","_BOMseen","_error_mode","_do_not_flush","RangeError","dec","Boolean","defineProperty","ignoreBOM","get","decode","input","bytes","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","input_stream","output","result","apply","serializeStream","TextEncoder","_encoder","_fatal","enc","console","warn","encode","opt_string","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","UTF8Encoder","count","temp","SingleByteDecoder","SingleByteEncoder","heading","GB18030Decoder","GB18030Encoder","gb18030_first","gb18030_second","gb18030_third","lead","gbk_flag","trail","byte1","byte2","byte3","byte4","Big5Decoder","Big5_lead","Big5Encoder","EUCJPDecoder","eucjp_jis0212_flag","eucjp_lead","EUCJPEncoder","ISO2022JPDecoder","states","ASCII","Roman","Katakana","LeadByte","TrailByte","EscapeStart","Escape","iso2022jp_decoder_state","iso2022jp_decoder_output_state","iso2022jp_lead","iso2022jp_output_flag","state","output_flag","ISO2022JPEncoder","jis0208","iso2022jp_state","ShiftJISDecoder","Shift_JIS_lead","lead_offset","ShiftJISEncoder","EUCKRDecoder","euckr_lead","EUCKREncoder","convertCodeUnitToBytes","code_unit","utf16be","UTF16Decoder","utf16_be","utf16_lead_byte","utf16_lead_surrogate","lead_surrogate","UTF16Encoder","concat","XUserDefinedDecoder","XUserDefinedEncoder","EncodingIndexes"],"sources":["/Users/victorcosta/Desktop/repositories/react-project/hooks-study/node_modules/text-encoding/lib/encoding.js"],"sourcesContent":["// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\n(function(global) {\n  'use strict';\n\n  // If we're in node require encoding-indexes and attach it to the global.\n  if (typeof module !== \"undefined\" && module.exports &&\n    !global[\"encoding-indexes\"]) {\n    global[\"encoding-indexes\"] =\n      require(\"./encoding-indexes.js\")[\"encoding-indexes\"];\n  }\n\n  //\n  // Utilities\n  //\n\n  /**\n   * @param {number} a The number to test.\n   * @param {number} min The minimum value in the range, inclusive.\n   * @param {number} max The maximum value in the range, inclusive.\n   * @return {boolean} True if a >= min and a <= max.\n   */\n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n\n  /**\n   * @param {!Array.<*>} array The array to check.\n   * @param {*} item The item to look for in the array.\n   * @return {boolean} True if the item appears in the array.\n   */\n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  var floor = Math.floor;\n\n  /**\n   * @param {*} o\n   * @return {Object}\n   */\n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError('Could not convert argument to dictionary');\n  }\n\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {!Array.<number>} Code points.\n   */\n  function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n    // 1. Let S be the DOMString value.\n    var s = String(string);\n\n    // 2. Let n be the length of S.\n    var n = s.length;\n\n    // 3. Initialize i to 0.\n    var i = 0;\n\n    // 4. Initialize U to be an empty sequence of Unicode characters.\n    var u = [];\n\n    // 5. While i < n:\n    while (i < n) {\n\n      // 1. Let c be the code unit in S at index i.\n      var c = s.charCodeAt(i);\n\n      // 2. Depending on the value of c:\n\n      // c < 0xD800 or c > 0xDFFF\n      if (c < 0xD800 || c > 0xDFFF) {\n        // Append to U the Unicode character with code point c.\n        u.push(c);\n      }\n\n      // 0xDC00 ≤ c ≤ 0xDFFF\n      else if (0xDC00 <= c && c <= 0xDFFF) {\n        // Append to U a U+FFFD REPLACEMENT CHARACTER.\n        u.push(0xFFFD);\n      }\n\n      // 0xD800 ≤ c ≤ 0xDBFF\n      else if (0xD800 <= c && c <= 0xDBFF) {\n        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n        // CHARACTER.\n        if (i === n - 1) {\n          u.push(0xFFFD);\n        }\n        // 2. Otherwise, i < n−1:\n        else {\n          // 1. Let d be the code unit in S at index i+1.\n          var d = s.charCodeAt(i + 1);\n\n          // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n          if (0xDC00 <= d && d <= 0xDFFF) {\n            // 1. Let a be c & 0x3FF.\n            var a = c & 0x3FF;\n\n            // 2. Let b be d & 0x3FF.\n            var b = d & 0x3FF;\n\n            // 3. Append to U the Unicode character with code point\n            // 2^16+2^10*a+b.\n            u.push(0x10000 + (a << 10) + b);\n\n            // 4. Set i to i+1.\n            i += 1;\n          }\n\n          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n          // U+FFFD REPLACEMENT CHARACTER.\n          else  {\n            u.push(0xFFFD);\n          }\n        }\n      }\n\n      // 3. Set i to i+1.\n      i += 1;\n    }\n\n    // 6. Return U.\n    return u;\n  }\n\n  /**\n   * @param {!Array.<number>} code_points Array of code points.\n   * @return {string} string String of UTF-16 code units.\n   */\n  function codePointsToString(code_points) {\n    var s = '';\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800,\n                                 (cp & 0x3FF) + 0xDC00);\n      }\n    }\n    return s;\n  }\n\n\n  //\n  // Implementation of Encoding specification\n  // https://encoding.spec.whatwg.org/\n  //\n\n  //\n  // 4. Terminology\n  //\n\n  /**\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n   * @param {number} a The number to test.\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n   */\n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n\n  /**\n   * An ASCII code point is a code point in the range U+0000 to\n   * U+007F, inclusive.\n   */\n  var isASCIICodePoint = isASCIIByte;\n\n\n  /**\n   * End-of-stream is a special token that signifies no more tokens\n   * are in the stream.\n   * @const\n   */ var end_of_stream = -1;\n\n  /**\n   * A stream represents an ordered sequence of tokens.\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  function Stream(tokens) {\n    /** @type {!Array.<number>} */\n    this.tokens = [].slice.call(tokens);\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n\n  Stream.prototype = {\n    /**\n     * @return {boolean} True if end-of-stream has been hit.\n     */\n    endOfStream: function() {\n      return !this.tokens.length;\n    },\n\n    /**\n     * When a token is read from a stream, the first token in the\n     * stream must be returned and subsequently removed, and\n     * end-of-stream must be returned otherwise.\n     *\n     * @return {number} Get the next token from the stream, or\n     * end_of_stream.\n     */\n     read: function() {\n      if (!this.tokens.length)\n        return end_of_stream;\n       return this.tokens.pop();\n     },\n\n    /**\n     * When one or more tokens are prepended to a stream, those tokens\n     * must be inserted, in given order, before the first token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n     * stream.\n     */\n    prepend: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n\n    /**\n     * When one or more tokens are pushed to a stream, those tokens\n     * must be inserted, in given order, after the last token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n     * stream.\n     */\n    push: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  };\n\n  //\n  // 5. Encodings\n  //\n\n  // 5.1 Encoders and decoders\n\n  /** @const */\n  var finished = -1;\n\n  /**\n   * @param {boolean} fatal If true, decoding errors raise an exception.\n   * @param {number=} opt_code_point Override the standard fallback code point.\n   * @return {number} The code point to insert on a decoding error.\n   */\n  function decoderError(fatal, opt_code_point) {\n    if (fatal)\n      throw TypeError('Decoder error');\n    return opt_code_point || 0xFFFD;\n  }\n\n  /**\n   * @param {number} code_point The code point that could not be encoded.\n   * @return {number} Always throws, no value is actually returned.\n   */\n  function encoderError(code_point) {\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\n  }\n\n  /** @interface */\n  function Decoder() {}\n  Decoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point, or |finished|.\n     */\n    handler: function(stream, bite) {}\n  };\n\n  /** @interface */\n  function Encoder() {}\n  Encoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of code points being encoded.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n     */\n    handler: function(stream, code_point) {}\n  };\n\n  // 5.2 Names and labels\n\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n  // https://github.com/google/closure-compiler/issues/247\n\n  /**\n   * @param {string} label The encoding label.\n   * @return {?{name:string,labels:Array.<string>}}\n   */\n  function getEncoding(label) {\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    label = String(label).trim().toLowerCase();\n\n    // 2. If label is an ASCII case-insensitive match for any of the\n    // labels listed in the table below, return the corresponding\n    // encoding, and failure otherwise.\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n    return null;\n  }\n\n  /**\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n   * @const\n   * @type {!Array.<{\n   *          heading: string,\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\n   *        }>}\n   */\n  var encodings = [\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"unicode-1-1-utf-8\",\n            \"utf-8\",\n            \"utf8\"\n          ],\n          \"name\": \"UTF-8\"\n        }\n      ],\n      \"heading\": \"The Encoding\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"866\",\n            \"cp866\",\n            \"csibm866\",\n            \"ibm866\"\n          ],\n          \"name\": \"IBM866\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin2\",\n            \"iso-8859-2\",\n            \"iso-ir-101\",\n            \"iso8859-2\",\n            \"iso88592\",\n            \"iso_8859-2\",\n            \"iso_8859-2:1987\",\n            \"l2\",\n            \"latin2\"\n          ],\n          \"name\": \"ISO-8859-2\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin3\",\n            \"iso-8859-3\",\n            \"iso-ir-109\",\n            \"iso8859-3\",\n            \"iso88593\",\n            \"iso_8859-3\",\n            \"iso_8859-3:1988\",\n            \"l3\",\n            \"latin3\"\n          ],\n          \"name\": \"ISO-8859-3\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin4\",\n            \"iso-8859-4\",\n            \"iso-ir-110\",\n            \"iso8859-4\",\n            \"iso88594\",\n            \"iso_8859-4\",\n            \"iso_8859-4:1988\",\n            \"l4\",\n            \"latin4\"\n          ],\n          \"name\": \"ISO-8859-4\"\n        },\n        {\n          \"labels\": [\n            \"csisolatincyrillic\",\n            \"cyrillic\",\n            \"iso-8859-5\",\n            \"iso-ir-144\",\n            \"iso8859-5\",\n            \"iso88595\",\n            \"iso_8859-5\",\n            \"iso_8859-5:1988\"\n          ],\n          \"name\": \"ISO-8859-5\"\n        },\n        {\n          \"labels\": [\n            \"arabic\",\n            \"asmo-708\",\n            \"csiso88596e\",\n            \"csiso88596i\",\n            \"csisolatinarabic\",\n            \"ecma-114\",\n            \"iso-8859-6\",\n            \"iso-8859-6-e\",\n            \"iso-8859-6-i\",\n            \"iso-ir-127\",\n            \"iso8859-6\",\n            \"iso88596\",\n            \"iso_8859-6\",\n            \"iso_8859-6:1987\"\n          ],\n          \"name\": \"ISO-8859-6\"\n        },\n        {\n          \"labels\": [\n            \"csisolatingreek\",\n            \"ecma-118\",\n            \"elot_928\",\n            \"greek\",\n            \"greek8\",\n            \"iso-8859-7\",\n            \"iso-ir-126\",\n            \"iso8859-7\",\n            \"iso88597\",\n            \"iso_8859-7\",\n            \"iso_8859-7:1987\",\n            \"sun_eu_greek\"\n          ],\n          \"name\": \"ISO-8859-7\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598e\",\n            \"csisolatinhebrew\",\n            \"hebrew\",\n            \"iso-8859-8\",\n            \"iso-8859-8-e\",\n            \"iso-ir-138\",\n            \"iso8859-8\",\n            \"iso88598\",\n            \"iso_8859-8\",\n            \"iso_8859-8:1988\",\n            \"visual\"\n          ],\n          \"name\": \"ISO-8859-8\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598i\",\n            \"iso-8859-8-i\",\n            \"logical\"\n          ],\n          \"name\": \"ISO-8859-8-I\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin6\",\n            \"iso-8859-10\",\n            \"iso-ir-157\",\n            \"iso8859-10\",\n            \"iso885910\",\n            \"l6\",\n            \"latin6\"\n          ],\n          \"name\": \"ISO-8859-10\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-13\",\n            \"iso8859-13\",\n            \"iso885913\"\n          ],\n          \"name\": \"ISO-8859-13\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-14\",\n            \"iso8859-14\",\n            \"iso885914\"\n          ],\n          \"name\": \"ISO-8859-14\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin9\",\n            \"iso-8859-15\",\n            \"iso8859-15\",\n            \"iso885915\",\n            \"iso_8859-15\",\n            \"l9\"\n          ],\n          \"name\": \"ISO-8859-15\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-16\"\n          ],\n          \"name\": \"ISO-8859-16\"\n        },\n        {\n          \"labels\": [\n            \"cskoi8r\",\n            \"koi\",\n            \"koi8\",\n            \"koi8-r\",\n            \"koi8_r\"\n          ],\n          \"name\": \"KOI8-R\"\n        },\n        {\n          \"labels\": [\n            \"koi8-ru\",\n            \"koi8-u\"\n          ],\n          \"name\": \"KOI8-U\"\n        },\n        {\n          \"labels\": [\n            \"csmacintosh\",\n            \"mac\",\n            \"macintosh\",\n            \"x-mac-roman\"\n          ],\n          \"name\": \"macintosh\"\n        },\n        {\n          \"labels\": [\n            \"dos-874\",\n            \"iso-8859-11\",\n            \"iso8859-11\",\n            \"iso885911\",\n            \"tis-620\",\n            \"windows-874\"\n          ],\n          \"name\": \"windows-874\"\n        },\n        {\n          \"labels\": [\n            \"cp1250\",\n            \"windows-1250\",\n            \"x-cp1250\"\n          ],\n          \"name\": \"windows-1250\"\n        },\n        {\n          \"labels\": [\n            \"cp1251\",\n            \"windows-1251\",\n            \"x-cp1251\"\n          ],\n          \"name\": \"windows-1251\"\n        },\n        {\n          \"labels\": [\n            \"ansi_x3.4-1968\",\n            \"ascii\",\n            \"cp1252\",\n            \"cp819\",\n            \"csisolatin1\",\n            \"ibm819\",\n            \"iso-8859-1\",\n            \"iso-ir-100\",\n            \"iso8859-1\",\n            \"iso88591\",\n            \"iso_8859-1\",\n            \"iso_8859-1:1987\",\n            \"l1\",\n            \"latin1\",\n            \"us-ascii\",\n            \"windows-1252\",\n            \"x-cp1252\"\n          ],\n          \"name\": \"windows-1252\"\n        },\n        {\n          \"labels\": [\n            \"cp1253\",\n            \"windows-1253\",\n            \"x-cp1253\"\n          ],\n          \"name\": \"windows-1253\"\n        },\n        {\n          \"labels\": [\n            \"cp1254\",\n            \"csisolatin5\",\n            \"iso-8859-9\",\n            \"iso-ir-148\",\n            \"iso8859-9\",\n            \"iso88599\",\n            \"iso_8859-9\",\n            \"iso_8859-9:1989\",\n            \"l5\",\n            \"latin5\",\n            \"windows-1254\",\n            \"x-cp1254\"\n          ],\n          \"name\": \"windows-1254\"\n        },\n        {\n          \"labels\": [\n            \"cp1255\",\n            \"windows-1255\",\n            \"x-cp1255\"\n          ],\n          \"name\": \"windows-1255\"\n        },\n        {\n          \"labels\": [\n            \"cp1256\",\n            \"windows-1256\",\n            \"x-cp1256\"\n          ],\n          \"name\": \"windows-1256\"\n        },\n        {\n          \"labels\": [\n            \"cp1257\",\n            \"windows-1257\",\n            \"x-cp1257\"\n          ],\n          \"name\": \"windows-1257\"\n        },\n        {\n          \"labels\": [\n            \"cp1258\",\n            \"windows-1258\",\n            \"x-cp1258\"\n          ],\n          \"name\": \"windows-1258\"\n        },\n        {\n          \"labels\": [\n            \"x-mac-cyrillic\",\n            \"x-mac-ukrainian\"\n          ],\n          \"name\": \"x-mac-cyrillic\"\n        }\n      ],\n      \"heading\": \"Legacy single-byte encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"chinese\",\n            \"csgb2312\",\n            \"csiso58gb231280\",\n            \"gb2312\",\n            \"gb_2312\",\n            \"gb_2312-80\",\n            \"gbk\",\n            \"iso-ir-58\",\n            \"x-gbk\"\n          ],\n          \"name\": \"GBK\"\n        },\n        {\n          \"labels\": [\n            \"gb18030\"\n          ],\n          \"name\": \"gb18030\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"big5\",\n            \"big5-hkscs\",\n            \"cn-big5\",\n            \"csbig5\",\n            \"x-x-big5\"\n          ],\n          \"name\": \"Big5\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseucpkdfmtjapanese\",\n            \"euc-jp\",\n            \"x-euc-jp\"\n          ],\n          \"name\": \"EUC-JP\"\n        },\n        {\n          \"labels\": [\n            \"csiso2022jp\",\n            \"iso-2022-jp\"\n          ],\n          \"name\": \"ISO-2022-JP\"\n        },\n        {\n          \"labels\": [\n            \"csshiftjis\",\n            \"ms932\",\n            \"ms_kanji\",\n            \"shift-jis\",\n            \"shift_jis\",\n            \"sjis\",\n            \"windows-31j\",\n            \"x-sjis\"\n          ],\n          \"name\": \"Shift_JIS\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Japanese encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseuckr\",\n            \"csksc56011987\",\n            \"euc-kr\",\n            \"iso-ir-149\",\n            \"korean\",\n            \"ks_c_5601-1987\",\n            \"ks_c_5601-1989\",\n            \"ksc5601\",\n            \"ksc_5601\",\n            \"windows-949\"\n          ],\n          \"name\": \"EUC-KR\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Korean encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"csiso2022kr\",\n            \"hz-gb-2312\",\n            \"iso-2022-cn\",\n            \"iso-2022-cn-ext\",\n            \"iso-2022-kr\"\n          ],\n          \"name\": \"replacement\"\n        },\n        {\n          \"labels\": [\n            \"utf-16be\"\n          ],\n          \"name\": \"UTF-16BE\"\n        },\n        {\n          \"labels\": [\n            \"utf-16\",\n            \"utf-16le\"\n          ],\n          \"name\": \"UTF-16LE\"\n        },\n        {\n          \"labels\": [\n            \"x-user-defined\"\n          ],\n          \"name\": \"x-user-defined\"\n        }\n      ],\n      \"heading\": \"Legacy miscellaneous encodings\"\n    }\n  ];\n\n  // Label to encoding registry.\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\n  var label_to_encoding = {};\n  encodings.forEach(function(category) {\n    category.encodings.forEach(function(encoding) {\n      encoding.labels.forEach(function(label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  });\n\n  // Registry of of encoder/decoder factories, by encoding name.\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\n  var encoders = {};\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\n  var decoders = {};\n\n  //\n  // 6. Indexes\n  //\n\n  /**\n   * @param {number} pointer The |pointer| to search for.\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in |index|.\n   */\n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to search for.\n   * @param {!Array.<?number>} index The |index| to search within.\n   * @return {?number} The first pointer corresponding to |code point| in\n   *     |index|, or null if |code point| is not in |index|.\n   */\n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n\n  /**\n   * @param {string} name Name of the index.\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\n   *  */\n  function index(name) {\n    if (!('encoding-indexes' in global)) {\n      throw Error(\"Indexes missing.\" +\n                  \" Did you forget to include encoding-indexes.js first?\");\n    }\n    return global['encoding-indexes'][name];\n  }\n\n  /**\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the gb18030 index.\n   */\n  function indexGB18030RangesCodePointFor(pointer) {\n    // 1. If pointer is greater than 39419 and less than 189000, or\n    // pointer is greater than 1237575, return null.\n    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))\n      return null;\n\n    // 2. If pointer is 7457, return code point U+E7C7.\n    if (pointer === 7457) return 0xE7C7;\n\n    // 3. Let offset be the last pointer in index gb18030 ranges that\n    // is equal to or less than pointer and let code point offset be\n    // its corresponding code point.\n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    }\n\n    // 4. Return a code point whose value is code point offset +\n    // pointer − offset.\n    return code_point_offset + pointer - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\n   * @return {number} The first pointer corresponding to |code point| in the\n   *     gb18030 index.\n   */\n  function indexGB18030RangesPointerFor(code_point) {\n    // 1. If code point is U+E7C7, return pointer 7457.\n    if (code_point === 0xE7C7) return 7457;\n\n    // 2. Let offset be the last code point in index gb18030 ranges\n    // that is equal to or less than code point and let pointer offset\n    // be its corresponding pointer.\n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    }\n\n    // 3. Return a pointer whose value is pointer offset + code point\n    // − offset.\n    return pointer_offset + code_point - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the Shift_JIS\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the Shift_JIS index.\n   */\n  function indexShiftJISPointerFor(code_point) {\n    // 1. Let index be index jis0208 excluding all entries whose\n    // pointer is in the range 8272 to 8835, inclusive.\n    shift_jis_index = shift_jis_index ||\n      index('jis0208').map(function(code_point, pointer) {\n        return inRange(pointer, 8272, 8835) ? null : code_point;\n      });\n    var index_ = shift_jis_index;\n\n    // 2. Return the index pointer for code point in index.\n    return index_.indexOf(code_point);\n  }\n  var shift_jis_index;\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the big5\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the big5 index.\n   */\n  function indexBig5PointerFor(code_point) {\n    // 1. Let index be index Big5 excluding all entries whose pointer\n    big5_index_no_hkscs = big5_index_no_hkscs ||\n      index('big5').map(function(code_point, pointer) {\n        return (pointer < (0xA1 - 0x81) * 157) ? null : code_point;\n      });\n    var index_ = big5_index_no_hkscs;\n\n    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n    // U+5345, return the last pointer corresponding to code point in\n    // index.\n    if (code_point === 0x2550 || code_point === 0x255E ||\n        code_point === 0x2561 || code_point === 0x256A ||\n        code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    }\n\n    // 3. Return the index pointer for code point in index.\n    return indexPointerFor(code_point, index_);\n  }\n  var big5_index_no_hkscs;\n\n  //\n  // 8. API\n  //\n\n  /** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n  // 8.1 Interface TextDecoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding;\n   *     defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n  function TextDecoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextDecoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options);\n\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n    this._decoder = null;\n    /** @private @type {boolean} */\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n    this._BOMseen = false;\n    /** @private @type {string} */\n    this._error_mode = 'replacement';\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    var encoding = getEncoding(label);\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name === 'replacement')\n      throw RangeError('Unknown encoding: ' + label);\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' +\n                  ' Did you forget to include encoding-indexes.js first?');\n    }\n\n    // 3. Let dec be a new TextDecoder object.\n    var dec = this;\n\n    // 4. Set dec's encoding to encoding.\n    dec._encoding = encoding;\n\n    // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n    if (Boolean(options['fatal']))\n      dec._error_mode = 'fatal';\n\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n    if (Boolean(options['ignoreBOM']))\n      dec._ignoreBOM = true;\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === 'fatal';\n      this.ignoreBOM = dec._ignoreBOM;\n    }\n\n    // 7. Return dec.\n    return dec;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\n      /** @this {TextDecoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n\n    // The fatal attribute's getter must return true if error mode\n    // is fatal, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\n      /** @this {TextDecoder} */\n      get: function() { return this._error_mode === 'fatal'; }\n    });\n\n    // The ignoreBOM attribute's getter must return true if ignore\n    // BOM flag is set, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n      /** @this {TextDecoder} */\n      get: function() { return this._ignoreBOM; }\n    });\n  }\n\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'});\n      this._BOMseen = false;\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    var input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      var token = input_stream.read();\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream)\n        break;\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token);\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished)\n        break;\n\n      if (result !== null) {\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    // A TextDecoder object also has an associated serialize stream\n    // algorithm...\n    /**\n     * @param {!Array.<number>} stream\n     * @return {string}\n     * @this {TextDecoder}\n     */\n    function serializeStream(stream) {\n      // 1. Let token be the result of reading from stream.\n      // (Done in-place on array, rather than as a stream)\n\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\n          !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          // 1. If token is U+FEFF, set BOM seen flag.\n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to stream.\n          this._BOMseen = true;\n        } else {\n          // 3. Otherwise, if token is not end-of-stream, append token\n          // to output.\n          // (no-op)\n        }\n      }\n      // 4. Otherwise, return output.\n      return codePointsToString(stream);\n    }\n\n    return serializeStream.call(this, output);\n  };\n\n  // 8.2 Interface TextEncoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} options NONSTANDARD.\n   */\n  function TextEncoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextEncoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    options = ToDictionary(options);\n\n    // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Encoder} */\n    this._encoder = null;\n\n    // Non-standard\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n    /** @private @type {string} */\n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n    // 1. Let enc be a new TextEncoder object.\n    var enc = this;\n\n    // 2. Set enc's encoding to UTF-8's encoder.\n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === 'replacement')\n        throw RangeError('Unknown encoding: ' + label);\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' +\n                    ' Did you forget to include encoding-indexes.js first?');\n      }\n      enc._encoding = encoding;\n    } else {\n      // Standard behavior.\n      enc._encoding = getEncoding('utf-8');\n\n      if (label !== undefined && 'console' in global) {\n        console.warn('TextEncoder constructor called with encoding label, '\n                     + 'which is ignored.');\n      }\n    }\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty)\n      this.encoding = enc._encoding.name.toLowerCase();\n\n    // 3. Return enc.\n    return enc;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\n      /** @this {TextEncoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n  }\n\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string === undefined ? '' : String(opt_string);\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n    if (!this._do_not_flush)\n      this._encoder = encoders[this._encoding.name]({\n        fatal: this._fatal === 'fatal'});\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 1. Convert input to a stream.\n    var input = new Stream(stringToCodePoints(opt_string));\n\n    // 2. Let output be a new stream\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    // 3. While true, run these substeps:\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read();\n      if (token === end_of_stream)\n        break;\n      // 2. Let result be the result of processing token for encoder,\n      // input, output.\n      result = this._encoder.handler(input, token);\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        output.push.apply(output, /**@type {!Array.<number>}*/(result));\n      else\n        output.push(result);\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n      this._encoder = null;\n    }\n    // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n    return new Uint8Array(output);\n  };\n\n\n  //\n  // 9. The encoding\n  //\n\n  // 9.1 utf-8\n\n  // 9.1.1 utf-8 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Decoder(options) {\n    var fatal = options.fatal;\n\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    var /** @type {number} */ utf8_code_point = 0,\n        /** @type {number} */ utf8_bytes_seen = 0,\n        /** @type {number} */ utf8_bytes_needed = 0,\n        /** @type {number} */ utf8_lower_boundary = 0x80,\n        /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        }\n\n        // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1;\n\n          // 2. Set UTF-8 code point to byte & 0x1F.\n          utf8_code_point = bite & 0x1F;\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0)\n            utf8_lower_boundary = 0xA0;\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED)\n            utf8_upper_boundary = 0x9F;\n          // 3. Set utf-8 bytes needed to 2.\n          utf8_bytes_needed = 2;\n          // 4. Set UTF-8 code point to byte & 0xF.\n          utf8_code_point = bite & 0xF;\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0)\n            utf8_lower_boundary = 0x90;\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4)\n            utf8_upper_boundary = 0x8F;\n          // 3. Set utf-8 bytes needed to 3.\n          utf8_bytes_needed = 3;\n          // 4. Set UTF-8 code point to byte & 0x7.\n          utf8_code_point = bite & 0x7;\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal);\n        }\n\n        // Return continue.\n        return null;\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Return error.\n        return decoderError(fatal);\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);\n\n      // 7. Increase utf-8 bytes seen by one.\n      utf8_bytes_seen += 1;\n\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed)\n        return null;\n\n      // 9. Let code point be utf-8 code point.\n      var code_point = utf8_code_point;\n\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n      // 11. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 9.1.2 utf-8 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset;\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2;\n        offset = 0xE0;\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3;\n        offset = 0xF0;\n      }\n\n      // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n      var bytes = [(code_point >> (6 * count)) + offset];\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> (6 * (count - 1));\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | (temp & 0x3F));\n\n        // 3. Decrease count by one.\n        count -= 1;\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes;\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-8'] = function(options) {\n    return new UTF8Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-8'] = function(options) {\n    return new UTF8Decoder(options);\n  };\n\n  //\n  // 10. Legacy single-byte encodings\n  //\n\n  // 10.1 single-byte decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Let code point be the index code point for byte − 0x80 in\n      // index single-byte.\n      var code_point = index[bite - 0x80];\n\n      // 4. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 10.2 single-byte encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {!Array.<?number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // single-byte.\n      var pointer = indexPointerFor(code_point, index);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        encoderError(code_point);\n\n      // 5. Return a byte whose value is pointer + 0x80.\n      return pointer + 0x80;\n    };\n  }\n\n  (function() {\n    if (!('encoding-indexes' in global))\n      return;\n    encodings.forEach(function(category) {\n      if (category.heading !== 'Legacy single-byte encodings')\n        return;\n      category.encodings.forEach(function(encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n        /** @param {{fatal: boolean}} options */\n        decoders[name] = function(options) {\n          return new SingleByteDecoder(idx, options);\n        };\n        /** @param {{fatal: boolean}} options */\n        encoders[name] = function(options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  }());\n\n  //\n  // 11. Legacy multi-byte Chinese (simplified) encodings\n  //\n\n  // 11.1 gbk\n\n  // 11.1.1 gbk decoder\n  // gbk's decoder is gb18030's decoder.\n  /** @param {{fatal: boolean}} options */\n  decoders['GBK'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n  // 11.1.2 gbk encoder\n  // gbk's encoder is gb18030's encoder with its gbk flag set.\n  /** @param {{fatal: boolean}} options */\n  encoders['GBK'] = function(options) {\n    return new GB18030Encoder(options, true);\n  };\n\n  // 11.2 gb18030\n\n  // 11.2.1 gb18030 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function GB18030Decoder(options) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    var /** @type {number} */ gb18030_first = 0x00,\n        /** @type {number} */ gb18030_second = 0x00,\n        /** @type {number} */ gb18030_third = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\n      // second, and gb18030 third are 0x00, return finished.\n      if (bite === end_of_stream && gb18030_first === 0x00 &&\n          gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      }\n      // 2. If byte is end-of-stream, and gb18030 first, gb18030\n      // second, or gb18030 third is not 0x00, set gb18030 first,\n      // gb18030 second, and gb18030 third to 0x00, and return error.\n      if (bite === end_of_stream &&\n          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||\n           gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n      var code_point;\n      // 3. If gb18030 third is not 0x00, run these substeps:\n      if (gb18030_third !== 0x00) {\n        // 1. Let code point be null.\n        code_point = null;\n        // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n        // code point to the index gb18030 ranges code point for\n        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor(\n              (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 +\n               gb18030_third - 0x81) * 10 + bite - 0x30);\n        }\n\n        // 3. Let buffer be a byte sequence consisting of gb18030\n        // second, gb18030 third, and byte, in order.\n        var buffer = [gb18030_second, gb18030_third, bite];\n\n        // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n        // 0x00.\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n\n        // 5. If code point is null, prepend buffer to stream and\n        // return error.\n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        }\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If gb18030 second is not 0x00, run these substeps:\n      if (gb18030_second !== 0x00) {\n\n        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n        // gb18030 third to byte and return continue.\n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        }\n\n        // 2. Prepend gb18030 second followed by byte to stream, set\n        // gb18030 first and gb18030 second to 0x00, and return error.\n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 5. If gb18030 first is not 0x00, run these substeps:\n      if (gb18030_first !== 0x00) {\n\n        // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n        // gb18030 second to byte and return continue.\n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        }\n\n        // 2. Let lead be gb18030 first, let pointer be null, and set\n        // gb18030 first to 0x00.\n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00;\n\n        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x41;\n\n        // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - offset);\n\n        // 5. Let code point be null if pointer is null and the index\n        // code point for pointer in index gb18030 otherwise.\n        code_point = pointer === null ? null :\n            indexCodePointFor(pointer, index('gb18030'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x80, return code point U+20AC.\n      if (bite === 0x80)\n        return 0x20AC;\n\n      // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 first to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      }\n\n      // 9. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 11.2.2 gb18030 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   * @param {boolean=} gbk_flag\n   */\n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gbk flag (initially unset).\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+E5E5, return error with code point.\n      if (code_point === 0xE5E5)\n        return encoderError(code_point);\n\n      // 4. If the gbk flag is set and code point is U+20AC, return\n      // byte 0x80.\n      if (gbk_flag && code_point === 0x20AC)\n        return 0x80;\n\n      // 5. Let pointer be the index pointer for code point in index\n      // gb18030.\n      var pointer = indexPointerFor(code_point, index('gb18030'));\n\n      // 6. If pointer is not null, run these substeps:\n      if (pointer !== null) {\n\n        // 1. Let lead be floor(pointer / 190) + 0x81.\n        var lead = floor(pointer / 190) + 0x81;\n\n        // 2. Let trail be pointer % 190.\n        var trail = pointer % 190;\n\n        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n        var offset = trail < 0x3F ? 0x40 : 0x41;\n\n        // 4. Return two bytes whose values are lead and trail + offset.\n        return [lead, trail + offset];\n      }\n\n      // 7. If gbk flag is set, return error with code point.\n      if (gbk_flag)\n        return encoderError(code_point);\n\n      // 8. Set pointer to the index gb18030 ranges pointer for code\n      // point.\n      pointer = indexGB18030RangesPointerFor(code_point);\n\n      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n      var byte1 = floor(pointer / 10 / 126 / 10);\n\n      // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n      pointer = pointer - byte1 * 10 * 126 * 10;\n\n      // 11. Let byte2 be floor(pointer / 10 / 126).\n      var byte2 = floor(pointer / 10 / 126);\n\n      // 12. Set pointer to pointer − byte2 × 10 × 126.\n      pointer = pointer - byte2 * 10 * 126;\n\n      // 13. Let byte3 be floor(pointer / 10).\n      var byte3 = floor(pointer / 10);\n\n      // 14. Let byte4 be pointer − byte3 × 10.\n      var byte4 = pointer - byte3 * 10;\n\n      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\n      return [byte1 + 0x81,\n              byte2 + 0x30,\n              byte3 + 0x81,\n              byte4 + 0x30];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['gb18030'] = function(options) {\n    return new GB18030Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['gb18030'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n\n  //\n  // 12. Legacy multi-byte Chinese (traditional) encodings\n  //\n\n  // 12.1 Big5\n\n  // 12.1.1 Big5 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Decoder(options) {\n    var fatal = options.fatal;\n    // Big5's decoder has an associated Big5 lead (initially 0x00).\n    var /** @type {number} */ Big5_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n      // Big5 lead to 0x00 and return error.\n      if (bite === end_of_stream && Big5_lead !== 0x00) {\n        Big5_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && Big5_lead === 0x00)\n        return finished;\n\n      // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n      // pointer be null, set Big5 lead to 0x00, and then run these\n      // substeps:\n      if (Big5_lead !== 0x00) {\n        var lead = Big5_lead;\n        var pointer = null;\n        Big5_lead = 0x00;\n\n        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x62;\n\n        // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\n          pointer = (lead - 0x81) * 157 + (bite - offset);\n\n        // 3. If there is a row in the table below whose first column\n        // is pointer, return the two code points listed in its second\n        // column\n        // Pointer | Code points\n        // --------+--------------\n        // 1133    | U+00CA U+0304\n        // 1135    | U+00CA U+030C\n        // 1164    | U+00EA U+0304\n        // 1166    | U+00EA U+030C\n        switch (pointer) {\n          case 1133: return [0x00CA, 0x0304];\n          case 1135: return [0x00CA, 0x030C];\n          case 1164: return [0x00EA, 0x0304];\n          case 1166: return [0x00EA, 0x030C];\n        }\n\n        // 4. Let code point be null if pointer is null and the index\n        // code point for pointer in index Big5 otherwise.\n        var code_point = (pointer === null) ? null :\n            indexCodePointFor(pointer, index('big5'));\n\n        // 5. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 6. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 7. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n      // lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        Big5_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 12.1.2 Big5 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index Big5 pointer for code point.\n      var pointer = indexBig5PointerFor(code_point);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      var lead = floor(pointer / 157) + 0x81;\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1)\n        return encoderError(code_point);\n\n      // 7. Let trail be pointer % 157.\n      var trail = pointer % 157;\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x62;\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Big5'] = function(options) {\n    return new Big5Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Big5'] = function(options) {\n    return new Big5Decoder(options);\n  };\n\n\n  //\n  // 13. Legacy multi-byte Japanese encodings\n  //\n\n  // 13.1 euc-jp\n\n  // 13.1.1 euc-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    var /** @type {boolean} */ eucjp_jis0212_flag = false,\n        /** @type {number} */ eucjp_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n      // euc-jp lead to 0x00, and return error.\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && eucjp_lead === 0x00)\n        return finished;\n\n      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n      // point whose value is 0xFF61 − 0xA1 + byte.\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 - 0xA1 + bite;\n      }\n\n      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n      // to byte, and return continue.\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n      // euc-jp lead to 0x00, and run these substeps:\n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00;\n\n        // 1. Let code point be null.\n        var code_point = null;\n\n        // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n        // inclusive, set code point to the index code point for (lead\n        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n        // jis0212 flag is unset and in index jis0212 otherwise.\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor(\n            (lead - 0xA1) * 94 + (bite - 0xA1),\n            index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n        }\n\n        // 3. Unset the euc-jp jis0212 flag.\n        eucjp_jis0212_flag = false;\n\n        // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n        // prepend byte to stream.\n        if (!inRange(bite, 0xA1, 0xFE))\n          stream.prepend(bite);\n\n        // 5. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n      // inclusive, set euc-jp lead to byte and return continue.\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 8. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.1.2 euc-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return two bytes whose values are 0x8E and code point −\n      // 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return [0x8E, code_point - 0xFF61 + 0xA1];\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 94) + 0xA1.\n      var lead = floor(pointer / 94) + 0xA1;\n\n      // 10. Let trail be pointer % 94 + 0xA1.\n      var trail = pointer % 94 + 0xA1;\n\n      // 11. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-JP'] = function(options) {\n    return new EUCJPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-JP'] = function(options) {\n    return new EUCJPDecoder(options);\n  };\n\n  // 13.2 iso-2022-jp\n\n  // 13.2.1 iso-2022-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    };\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\n        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\n        /** @type {number} */ iso2022jp_lead = 0x00,\n        /** @type {boolean} */ iso2022jp_output_flag = false;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // switching on iso-2022-jp decoder state:\n      switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\n            && bite !== 0x0F && bite !== 0x1B) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5C) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00A5;\n        }\n\n        // 0x7E\n        if (bite === 0x7E) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203E;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\n            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5F)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 − 0x21 + byte.\n          iso2022jp_output_flag = false;\n          return 0xFF61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null)\n            return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42)\n          state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4A)\n          state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49)\n          state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\n          state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n      }\n    };\n  }\n\n  // 13.2.2 iso-2022-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal;\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var /** @type {number} */ iso2022jp_state = states.ASCII;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\n      // state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (code_point === end_of_stream &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 2. If code point is end-of-stream and iso-2022-jp encoder\n      // state is ASCII, return finished.\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)\n        return finished;\n\n      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n      if ((iso2022jp_state === states.ASCII ||\n           iso2022jp_state === states.Roman) &&\n          (code_point === 0x000E || code_point === 0x000F ||\n           code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      }\n\n      // 4. If iso-2022-jp encoder state is ASCII and code point is an\n      // ASCII code point, return a byte whose value is code point.\n      if (iso2022jp_state === states.ASCII &&\n          isASCIICodePoint(code_point))\n        return code_point;\n\n      // 5. If iso-2022-jp encoder state is Roman and code point is an\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n      // or U+203E, run these substeps:\n      if (iso2022jp_state === states.Roman &&\n          ((isASCIICodePoint(code_point) &&\n           code_point !== 0x005C && code_point !== 0x007E) ||\n          (code_point == 0x00A5 || code_point == 0x203E))) {\n\n        // 1. If code point is an ASCII code point, return a byte\n        // whose value is code point.\n        if (isASCIICodePoint(code_point))\n          return code_point;\n\n        // 2. If code point is U+00A5, return byte 0x5C.\n        if (code_point === 0x00A5)\n          return 0x5C;\n\n        // 3. If code point is U+203E, return byte 0x7E.\n        if (code_point === 0x203E)\n          return 0x7E;\n      }\n\n      // 6. If code point is an ASCII code point, and iso-2022-jp\n      // encoder state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (isASCIICodePoint(code_point) &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n      // encoder state is not Roman, prepend code point to stream, set\n      // iso-2022-jp encoder state to Roman, and return three bytes\n      // 0x1B 0x28 0x4A.\n      if ((code_point === 0x00A5 || code_point === 0x203E) &&\n          iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      }\n\n      // 8. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 9. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 10. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n      // point to stream, set iso-2022-jp encoder state to jis0208,\n      // and return three bytes 0x1B 0x24 0x42.\n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      }\n\n      // 12. Let lead be floor(pointer / 94) + 0x21.\n      var lead = floor(pointer / 94) + 0x21;\n\n      // 13. Let trail be pointer % 94 + 0x21.\n      var trail = pointer % 94 + 0x21;\n\n      // 14. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPDecoder(options);\n  };\n\n  // 13.3 Shift_JIS\n\n  // 13.3.1 Shift_JIS decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal;\n    // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n    var /** @type {number} */ Shift_JIS_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n      // set Shift_JIS lead to 0x00 and return error.\n      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n        Shift_JIS_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n      // return finished.\n      if (bite === end_of_stream && Shift_JIS_lead === 0x00)\n        return finished;\n\n      // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n      // let pointer be null, set Shift_JIS lead to 0x00, and then run\n      // these substeps:\n      if (Shift_JIS_lead !== 0x00) {\n        var lead = Shift_JIS_lead;\n        var pointer = null;\n        Shift_JIS_lead = 0x00;\n\n        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n        // otherwise.\n        var offset = (bite < 0x7F) ? 0x40 : 0x41;\n\n        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n        // 0xC1 otherwise.\n        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;\n\n        // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n        // 188 + byte − offset.\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\n          pointer = (lead - lead_offset) * 188 + bite - offset;\n\n        // 4. If pointer is in the range 8836 to 10715, inclusive,\n        // return a code point whose value is 0xE000 − 8836 + pointer.\n        if (inRange(pointer, 8836, 10715))\n          return 0xE000 - 8836 + pointer;\n\n        // 5. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index jis0208 otherwise.\n        var code_point = (pointer === null) ? null :\n              indexCodePointFor(pointer, index('jis0208'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte or 0x80, return a code point\n      // whose value is byte.\n      if (isASCIIByte(bite) || bite === 0x80)\n        return bite;\n\n      // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n      // code point whose value is 0xFF61 − 0xA1 + byte.\n      if (inRange(bite, 0xA1, 0xDF))\n        return 0xFF61 - 0xA1 + bite;\n\n      // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n      // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n      // continue.\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        Shift_JIS_lead = bite;\n        return null;\n      }\n\n      // 7. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.3.2 Shift_JIS encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point or U+0080, return a\n      // byte whose value is code point.\n      if (isASCIICodePoint(code_point) || code_point === 0x0080)\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return a byte whose value is code point − 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return code_point - 0xFF61 + 0xA1;\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index Shift_JIS pointer for code point.\n      var pointer = indexShiftJISPointerFor(code_point);\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 188).\n      var lead = floor(pointer / 188);\n\n      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n      // 0xC1 otherwise.\n      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;\n\n      // 11. Let trail be pointer % 188.\n      var trail = pointer % 188;\n\n      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n      // otherwise.\n      var offset = (trail < 0x3F) ? 0x40 : 0x41;\n\n      // 13. Return two bytes whose values are lead + lead offset and\n      // trail + offset.\n      return [lead + lead_offset, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Shift_JIS'] = function(options) {\n    return new ShiftJISEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Shift_JIS'] = function(options) {\n    return new ShiftJISDecoder(options);\n  };\n\n  //\n  // 14. Legacy multi-byte Korean encodings\n  //\n\n  // 14.1 euc-kr\n\n  // 14.1.1 euc-kr decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKRDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n    var /** @type {number} */ euckr_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n      // euc-kr lead to 0x00 and return error.\n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && euckr_lead === 0)\n        return finished;\n\n      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n      // pointer be null, set euc-kr lead to 0x00, and then run these\n      // substeps:\n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00;\n\n        // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n        // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n        if (inRange(bite, 0x41, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n        // 2. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index euc-kr otherwise.\n        var code_point = (pointer === null)\n              ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n        // 3. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (pointer === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 4. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 5. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // euc-kr lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 14.1.2 euc-kr encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // euc-kr.\n      var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 6. Let trail be pointer % 190 + 0x41.\n      var trail = (pointer % 190) + 0x41;\n\n      // 7. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-KR'] = function(options) {\n    return new EUCKREncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-KR'] = function(options) {\n    return new EUCKRDecoder(options);\n  };\n\n\n  //\n  // 15. Legacy miscellaneous encodings\n  //\n\n  // 15.1 replacement\n\n  // Not needed - API throws RangeError\n\n  // 15.2 Common infrastructure for utf-16be and utf-16le\n\n  /**\n   * @param {number} code_unit\n   * @param {boolean} utf16be\n   * @return {!Array.<number>} bytes\n   */\n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    // 1. Let byte1 be code unit >> 8.\n    var byte1 = code_unit >> 8;\n\n    // 2. Let byte2 be code unit & 0x00FF.\n    var byte2 = code_unit & 0x00FF;\n\n    // 3. Then return the bytes in order:\n        // utf-16be flag is set: byte1, then byte2.\n    if (utf16be)\n      return [byte1, byte2];\n    // utf-16be flag is unset: byte2, then byte1.\n    return [byte2, byte1];\n  }\n\n  // 15.2.1 shared utf-16 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var /** @type {?number} */ utf16_lead_byte = null,\n        /** @type {?number} */ utf16_lead_surrogate = null;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\n      // utf-16 lead surrogate to null, and return error.\n      if (bite === end_of_stream && (utf16_lead_byte !== null ||\n                                utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n      // lead surrogate are null, return finished.\n      if (bite === end_of_stream && utf16_lead_byte === null &&\n          utf16_lead_surrogate === null) {\n        return finished;\n      }\n\n      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n      // and return continue.\n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      }\n\n      // 4. Let code unit be the result of:\n      var code_unit;\n      if (utf16_be) {\n        // utf-16be decoder flag is set\n        //   (utf-16 lead byte << 8) + byte.\n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        // utf-16be decoder flag is unset\n        //   (byte << 8) + utf-16 lead byte.\n        code_unit = (bite << 8) + utf16_lead_byte;\n      }\n      // Then set utf-16 lead byte to null.\n      utf16_lead_byte = null;\n\n      // 5. If utf-16 lead surrogate is not null, let lead surrogate\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n      // and then run these substeps:\n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null;\n\n        // 1. If code unit is in the range U+DC00 to U+DFFF,\n        // inclusive, return a code point whose value is 0x10000 +\n        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +\n              (code_unit - 0xDC00);\n        }\n\n        // 2. Prepend the sequence resulting of converting code unit\n        // to bytes using utf-16be decoder flag to stream and return\n        // error.\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      }\n\n      // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n      // set utf-16 lead surrogate to code unit and return continue.\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      }\n\n      // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n      // return error.\n      if (inRange(code_unit, 0xDC00, 0xDFFF))\n        return decoderError(fatal);\n\n      // 8. Return code point code unit.\n      return code_unit;\n    };\n  }\n\n  // 15.2.2 shared utf-16 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n      // return the sequence resulting of converting code point to\n      // bytes using utf-16be encoder flag.\n      if (inRange(code_point, 0x0000, 0xFFFF))\n        return convertCodeUnitToBytes(code_point, utf16_be);\n\n      // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n      // converted to bytes using utf-16be encoder flag.\n      var lead = convertCodeUnitToBytes(\n        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);\n\n      // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n      // converted to bytes using utf-16be encoder flag.\n      var trail = convertCodeUnitToBytes(\n        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);\n\n      // 5. Return a byte sequence of lead followed by trail.\n      return lead.concat(trail);\n    };\n  }\n\n  // 15.3 utf-16be\n  // 15.3.1 utf-16be decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16BE'] = function(options) {\n    return new UTF16Encoder(true, options);\n  };\n  // 15.3.2 utf-16be encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16BE'] = function(options) {\n    return new UTF16Decoder(true, options);\n  };\n\n  // 15.4 utf-16le\n  // 15.4.1 utf-16le decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16LE'] = function(options) {\n    return new UTF16Encoder(false, options);\n  };\n  // 15.4.2 utf-16le encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16LE'] = function(options) {\n    return new UTF16Decoder(false, options);\n  };\n\n  // 15.5 x-user-defined\n\n  // 15.5.1 x-user-defined decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n      return 0xF780 + bite - 0x80;\n    };\n  }\n\n  // 15.5.2 x-user-defined encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1.If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n      // return a byte whose value is code point − 0xF780 + 0x80.\n      if (inRange(code_point, 0xF780, 0xF7FF))\n        return code_point - 0xF780 + 0x80;\n\n      // 4. Return error with code point.\n      return encoderError(code_point);\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['x-user-defined'] = function(options) {\n    return new XUserDefinedEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['x-user-defined'] = function(options) {\n    return new XUserDefinedDecoder(options);\n  };\n\n  if (!global['TextEncoder'])\n    global['TextEncoder'] = TextEncoder;\n  if (!global['TextDecoder'])\n    global['TextDecoder'] = TextDecoder;\n\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = {\n      TextEncoder: global['TextEncoder'],\n      TextDecoder: global['TextDecoder'],\n      EncodingIndexes: global[\"encoding-indexes\"]\n    };\n  }\n\n// For strict environments where `this` inside the global scope\n// is `undefined`, take a pure object instead\n}(this || {}));"],"mappings":"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"},"metadata":{},"sourceType":"script"}