{"ast":null,"code":"const domParse = require('./dom-parse.js');\n\nconst sinon = require('sinon');\n\nconst nodeStore = require('./nodeStore.js'); // Current asserts to check. \n\n\nlet currentAsserts = [];\n\nfunction getLocation(assertion) {\n  if (assertion.selector === 'node') return nodeStore.storage.address[assertion.loc.toString()];\n  if (assertion.selector === 'id') return document.getElementById(assertion.selectorName);\n  if (assertion.selector === 'class') return document.getElementsByClassName(assertion.selectorName);\n  if (assertion.selector === 'tag') return document.getElementsByTagName(assertion.selector);\n  if (assertion.selector === 'component') return nodeStore.storage.node[assertion.selectorName];\n} // Get the actual DOM node at the supplied address and return it\n\n\nfunction getNode(address) {\n  let result = document.getElementById(address[0]);\n\n  for (let i = 1; i < address.length; i++) {\n    result = result.children[address[i]];\n  }\n\n  return result;\n}\n\nfunction actionController(current, blockName) {\n  // We hit this if we have reached an action that hasn't been set up yet\n  // We add a spy on the specified node and then stop checking this assertion block\n  if (current.added === false) {\n    current.added = true;\n    const spy = sinon.spy();\n    let currNode = getNode(current.loc);\n    currNode.addEventListener(current.event, spy);\n\n    if (current.event === 'keypress') {\n      current.lastInput = '';\n      currNode.addEventListener(current.event, () => current.lastInput = currNode.value);\n    }\n\n    current.spy = spy;\n    return false;\n  } // We hit this if our current assert is an action that has not happened yet\n  // We stop checking this assertion block\n\n\n  const enterEvent = current.event === 'keypress' && current.spy.called && current.spy.args[current.spy.args.length - 1][0].key === 'Enter' && current.lastInput === current.inputValue;\n  if (current.event === 'keypress' && !enterEvent) return false; // We hit this if our current assert is an action that has happened\n  // We remove the assertion from the assertion block and then we go to the next while loop cycle\n\n  if (enterEvent || current.spy.called === true) {\n    const resultMessage = {\n      // TODO: this property might need to change to get assertion block name from chrome extension message\n      assertionBlock: blockName,\n      assertID: current.assertID,\n      result: true,\n      comparator: current.type\n    };\n    sendResult(resultMessage);\n    return true;\n  }\n\n  return false;\n}\n\nfunction modifierController(modifier, data) {\n  if (modifier === '.length') {\n    return data.length;\n  } else if (modifier[0] === '[') {\n    let index = modifier.slice(1, -1);\n    return data[index];\n  }\n} // Check our current assertion blocks and run any available assertions. \n// Runs on every state change\n// TAKE OUT CURRENT ASSERTS FROM ARGUMENT ONCE DONE WITH DUMMY DATA\n\n\nfunction checkAssert() {\n  // For debugging purposes, should be removed prior to release\n  if (currentAsserts.length === 0) {\n    return;\n  } // Loop through all current assertion blocks\n\n\n  currentAsserts.forEach((currAssert, i) => {\n    // Loop through the current assertion block that we are testing\n    // This can probably be refactored/cleaned up\n    while (currAssert.asserts.length > 0) {\n      let current = currAssert.asserts[0]; // if action\n\n      if (current.type === 'action') {\n        if (actionController(current, currAssert.name)) {\n          currAssert.asserts.shift();\n          continue;\n        }\n\n        break;\n      } // Compose result message to be sent to chrome extension\n\n\n      const resultMessage = {\n        // TODO: this property might need to change to get assertion block name from chrome extension message\n        assertionBlock: currAssert.name,\n        assertID: current.assertID\n      }; // current becomes the first assertion\n\n      let result;\n      let dataToTest;\n      if (current.selector === 'node') dataToTest = nodeTest(current);\n      if (current.selector === 'component') dataToTest = componentTest(current);\n      if (current.selector === 'id') dataToTest = idTest(current);\n      if (current.selector === 'class') dataToTest = classTest(current);\n      if (current.selector === 'tag') dataToTest = tagTest(current); // Convert our value to the specified variable type\n\n      current.value = convertType(current); // We hit this if the assertion is equal\n      // In this case, we make the specified comparison and send the result back to the chrome extension\n\n      result = convertResult(current.type, dataToTest, current.value); // Assign test result details to resultMessage\n\n      resultMessage.expected = current.value;\n      resultMessage.actual = dataToTest;\n      resultMessage.comparator = current.type;\n      resultMessage.result = result;\n      sendResult(resultMessage);\n      currAssert.asserts.shift();\n    } // We hit this if we have removed all of the assertions from our assertion block\n    // In that case, we remove the assertion block from our list of current assertion blocks\n\n\n    if (currAssert.asserts.length === 0) currentAsserts.splice(i, 1);\n  });\n} // Collects data to evaluate for tag tests. \n\n\nfunction tagTest(current) {\n  if (current.selectorModifier === '.length') return nodeStore.storage.tag[current.selectorName].length;\n  let index = current.selectorModifier.slice(1, -1);\n  let address = nodeStore.storage.tag[current.selectorName][index];\n  let dataToTest = getNode(address);\n  return dataToTest.innerText;\n} // Collects data to evaluate for class tests. \n\n\nfunction classTest(current) {\n  if (current.selectorModifier === '.length') return nodeStore.storage.class[current.selectorName].length;\n  let index = current.selectorModifier.slice(1, -1);\n  let address = nodeStore.storage.class[current.selectorName][index];\n  let dataToTest = getNode(address);\n  return dataToTest.innerText;\n} // Collects data to evaluate for id tests. \n\n\nfunction idTest(current) {\n  return document.getElementById(current.selectorName).innerText;\n} // Collects data to evaluate for component tests. \n\n\nfunction componentTest(current) {\n  if (current.selectorModifier === '.length') return nodeStore.storage.node[current.selectorName].address.length;\n  let index = current.selectorModifier.slice(1, -1);\n  let address = nodeStore.storage.node[current.selectorName].address[index].toString();\n  let dataToTest = nodeStore.storage.address[address];\n  if (current.source === 'state') dataToTest = dataToTest.state[current.property];\n  if (current.source === 'props') dataToTest = dataToTest.props[current.property];\n  if (current.modifier) dataToTest = modifierController(current.modifier, dataToTest);\n  return dataToTest;\n} // Collects data to evaluate for node tests. \n\n\nfunction nodeTest(current) {\n  let dataToTest = getLocation(current); // Check selector modifier field for input and determine value to test\n\n  if (current.selectorModifier) dataToTest = modifierController(current.selectorModifier, dataToTest); //if (current.source === 'text') dataToTest = dataToTest.innerText;\n\n  if (current.source === 'state') dataToTest = dataToTest.state[current.property];\n  if (current.source === 'props') dataToTest = dataToTest.props[current.property];\n  if (current.modifier) dataToTest = modifierController(current.modifier, dataToTest);\n  return dataToTest;\n} // Returns evaluation result based on the type of test being run\n\n\nfunction convertResult(type, dataToTest, value) {\n  if (type === 'equal') {\n    return dataToTest === value;\n  } else if (type === 'greaterthan') {\n    return dataToTest > value;\n  } else if (type === 'lessthan') {\n    return dataToTest < value;\n  } else if (type === 'notequal') {\n    return dataToTest !== value;\n  }\n} // Converts data to the specific type mentioned in the test\n\n\nfunction convertType(current) {\n  switch (current.dataType) {\n    case 'boolean':\n      return Boolean(current.value);\n\n    case 'number':\n      return +current.value;\n\n    case 'null':\n      return null;\n\n    case 'undefined':\n      return undefined;\n\n    case 'string':\n      return current.value;\n\n    default:\n      return 'Data type block failed';\n  }\n} // Send result back to chrome extension\n\n\nfunction sendResult(messageObject) {\n  window.postMessage({\n    type: 'test-result',\n    data: messageObject\n  }, \"*\");\n} // Add assert is called from inject.js whenever an assertion message is recieved from the chrome extension\n\n\nfunction addAssert(freshAssert) {\n  // assertBundle is the eventual assertion block that we will be adding\n  let assertBundle = {};\n  assertBundle.asserts = [];\n  assertBundle.name = freshAssert.name; // This is a flag to determine whether we have added an action yet on this assertion block\n  // We want to have the ability to see if a specific event happens more than once so we only want to have one spy set up at a time\n\n  let actionAdded = false; // Loop through our fresh assert bundle so that we can add it to our current asserts\n\n  freshAssert.asserts.forEach(curr => {\n    // 'actions' require a special logic and need to be reconstructed before inserting\n    if (curr.type === 'action') {\n      // base info for every action\n      let newAssert = {};\n      newAssert.assertID = curr.assertID;\n      newAssert.loc = curr.loc;\n      newAssert.type = 'action';\n      newAssert.event = curr.event;\n      newAssert.inputValue = curr.inputValue; // This is how we will handle our first action in the assertion bundle\n      // For this one, we will add a spy  \n\n      if (!actionAdded) {\n        let spy = sinon.spy();\n        let currNode = getNode(curr.loc);\n        currNode.addEventListener(curr.event, spy);\n        newAssert.spy = spy;\n        newAssert.added = true; // Here we set our flag so that we only add one spy to this bundle at this time\n\n        actionAdded = true;\n\n        if (curr.event === 'keypress') {\n          newAssert.lastInput = '';\n          currNode.addEventListener(curr.event, () => newAssert.lastInput = currNode.value);\n        }\n      } else {\n        // Any actions other than the first will get no spy and have the added property be false\n        newAssert.added = false;\n      } // Here we add our newly made action assert to the bundle  \n\n\n      assertBundle.asserts.push(newAssert);\n    } else {\n      // We just pass in an evaluation assert as is  \n      assertBundle.asserts.push(curr);\n    }\n  }); // Grab our new bundle and add it our current assert queue\n\n  currentAsserts.push(assertBundle);\n  checkAssert();\n} // Deletes an assertion block based on the name given\n\n\nfunction deleteBlock(name) {\n  for (let i = 0; i < currentAsserts.length; i++) {\n    if (currentAsserts[i].name === name) {\n      currentAsserts.splice(i, 1);\n      break;\n    }\n  }\n}\n\nmodule.exports = {\n  checkAssert,\n  addAssert,\n  deleteBlock\n};","map":{"version":3,"names":["domParse","require","sinon","nodeStore","currentAsserts","getLocation","assertion","selector","storage","address","loc","toString","document","getElementById","selectorName","getElementsByClassName","getElementsByTagName","node","getNode","result","i","length","children","actionController","current","blockName","added","spy","currNode","addEventListener","event","lastInput","value","enterEvent","called","args","key","inputValue","resultMessage","assertionBlock","assertID","comparator","type","sendResult","modifierController","modifier","data","index","slice","checkAssert","forEach","currAssert","asserts","name","shift","dataToTest","nodeTest","componentTest","idTest","classTest","tagTest","convertType","convertResult","expected","actual","splice","selectorModifier","tag","innerText","class","source","state","property","props","dataType","Boolean","undefined","messageObject","window","postMessage","addAssert","freshAssert","assertBundle","actionAdded","curr","newAssert","push","deleteBlock","module","exports"],"sources":["/Users/victorcosta/Desktop/repositories/react-project/hooks-study/node_modules/react-vt/src/assert.js"],"sourcesContent":["const domParse = require('./dom-parse.js');\nconst sinon = require('sinon'); \nconst nodeStore = require('./nodeStore.js');\n\n// Current asserts to check. \nlet currentAsserts = [];\n\nfunction getLocation(assertion) {\n  if (assertion.selector === 'node') return nodeStore.storage.address[assertion.loc.toString()];\n  if (assertion.selector === 'id') return document.getElementById(assertion.selectorName);\n  if (assertion.selector === 'class') return document.getElementsByClassName(assertion.selectorName);\n  if (assertion.selector === 'tag') return document.getElementsByTagName(assertion.selector);\n  if (assertion.selector === 'component') return nodeStore.storage.node[assertion.selectorName];\n}\n\n// Get the actual DOM node at the supplied address and return it\nfunction getNode(address) {\n  let result = document.getElementById(address[0]); \n  for (let i = 1; i < address.length; i++) {\n    result = result.children[address[i]];\n  }\n  return result; \n}\n\n\nfunction actionController(current, blockName) {\n  // We hit this if we have reached an action that hasn't been set up yet\n  // We add a spy on the specified node and then stop checking this assertion block\n  if (current.added === false) {\n    current.added = true; \n    const spy = sinon.spy();\n    let currNode = getNode(current.loc);\n    currNode.addEventListener(current.event, spy);\n    if (current.event === 'keypress') {\n      current.lastInput = '';\n      currNode.addEventListener(current.event, () => current.lastInput = currNode.value);\n    }\n    current.spy = spy; \n    return false; \n  }\n  \n  // We hit this if our current assert is an action that has not happened yet\n  // We stop checking this assertion block\n  const enterEvent = (current.event === 'keypress' && current.spy.called && current.spy.args[current.spy.args.length - 1][0].key === 'Enter' && current.lastInput === current.inputValue); \n  if (current.event === 'keypress' && !enterEvent) return false; \n  // We hit this if our current assert is an action that has happened\n  // We remove the assertion from the assertion block and then we go to the next while loop cycle\n  if (enterEvent || current.spy.called === true) {\n    const resultMessage = {\n      // TODO: this property might need to change to get assertion block name from chrome extension message\n      assertionBlock: blockName,\n      assertID: current.assertID,\n      result: true,\n      comparator: current.type,\n    };\n    sendResult(resultMessage);\n    return true;\n  }\n  return false;\n}\n\nfunction modifierController(modifier, data) {\n  if (modifier === '.length') {\n    return data.length;\n  } else if (modifier[0] === '[') {\n    let index = modifier.slice(1, -1);\n    return data[index];\n  }\n}\n\n// Check our current assertion blocks and run any available assertions. \n// Runs on every state change\n\n// TAKE OUT CURRENT ASSERTS FROM ARGUMENT ONCE DONE WITH DUMMY DATA\nfunction checkAssert() {\n  // For debugging purposes, should be removed prior to release\n  if (currentAsserts.length === 0) {\n    return;\n  }\n\n  // Loop through all current assertion blocks\n  currentAsserts.forEach((currAssert, i) => {\n\n    // Loop through the current assertion block that we are testing\n    // This can probably be refactored/cleaned up\n    while (currAssert.asserts.length > 0) {\n      let current = currAssert.asserts[0];\n      // if action\n      if (current.type === 'action') {\n        if (actionController(current, currAssert.name)) {\n          currAssert.asserts.shift();\n          continue;\n        }\n        break;\n      }\n      \n      // Compose result message to be sent to chrome extension\n      const resultMessage = {\n        // TODO: this property might need to change to get assertion block name from chrome extension message\n        assertionBlock: currAssert.name,\n        assertID: current.assertID,\n      };\n      // current becomes the first assertion\n      let result;\n      let dataToTest;\n      if (current.selector === 'node') dataToTest = nodeTest(current);\n      if (current.selector === 'component') dataToTest = componentTest(current);\n      if (current.selector === 'id') dataToTest = idTest(current);\n      if (current.selector === 'class') dataToTest = classTest(current);\n      if (current.selector === 'tag') dataToTest = tagTest(current);\n            \n      // Convert our value to the specified variable type\n      current.value = convertType(current);\n\n      // We hit this if the assertion is equal\n      // In this case, we make the specified comparison and send the result back to the chrome extension\n      result = convertResult(current.type, dataToTest, current.value); \n\n\n      // Assign test result details to resultMessage\n      resultMessage.expected = current.value;\n      resultMessage.actual = dataToTest;\n      resultMessage.comparator = current.type;\n      resultMessage.result = result;\n      sendResult(resultMessage);\n      currAssert.asserts.shift();\n    }\n    // We hit this if we have removed all of the assertions from our assertion block\n    // In that case, we remove the assertion block from our list of current assertion blocks\n    if (currAssert.asserts.length === 0) currentAsserts.splice(i,1); \n  });\n}\n\n // Collects data to evaluate for tag tests. \nfunction tagTest(current) {\n  if (current.selectorModifier === '.length') return nodeStore.storage.tag[current.selectorName].length;\n  let index = current.selectorModifier.slice(1, -1);\n  let address = nodeStore.storage.tag[current.selectorName][index]; \n  let dataToTest = getNode(address); \n  return dataToTest.innerText; \n}\n\n // Collects data to evaluate for class tests. \nfunction classTest(current) {\n  if (current.selectorModifier === '.length') return nodeStore.storage.class[current.selectorName].length;\n  let index = current.selectorModifier.slice(1, -1);\n  let address = nodeStore.storage.class[current.selectorName][index]; \n  let dataToTest = getNode(address); \n  return dataToTest.innerText; \n}\n\n // Collects data to evaluate for id tests. \nfunction idTest(current) {\n  return document.getElementById(current.selectorName).innerText; \n}\n\n // Collects data to evaluate for component tests. \nfunction componentTest(current) {\n  if (current.selectorModifier === '.length') return nodeStore.storage.node[current.selectorName].address.length;\n  let index = current.selectorModifier.slice(1, -1);\n  let address = nodeStore.storage.node[current.selectorName].address[index].toString(); \n  let dataToTest = nodeStore.storage.address[address]; \n  if (current.source === 'state') dataToTest = dataToTest.state[current.property];\n  if (current.source === 'props') dataToTest = dataToTest.props[current.property];\n  if (current.modifier) dataToTest = modifierController(current.modifier, dataToTest); \n  return dataToTest; \n}\n\n // Collects data to evaluate for node tests. \nfunction nodeTest(current) {\n  let dataToTest = getLocation(current);\n\n  // Check selector modifier field for input and determine value to test\n  if (current.selectorModifier) dataToTest = modifierController(current.selectorModifier, dataToTest);\n  //if (current.source === 'text') dataToTest = dataToTest.innerText;\n  if (current.source === 'state') dataToTest = dataToTest.state[current.property];\n  if (current.source === 'props') dataToTest = dataToTest.props[current.property];\n  if (current.modifier) dataToTest = modifierController(current.modifier, dataToTest); \n  return dataToTest; \n}\n\n // Returns evaluation result based on the type of test being run\nfunction convertResult(type, dataToTest, value) {\n  if (type === 'equal') {\n    return dataToTest === value;\n  } else if (type === 'greaterthan') {\n    return dataToTest > value;\n  } else if (type === 'lessthan') {\n    return dataToTest < value;\n  } else if (type === 'notequal') {\n    return dataToTest !== value;\n  }\n}\n\n // Converts data to the specific type mentioned in the test\nfunction convertType(current) {\n  switch (current.dataType) {\n    case 'boolean':\n      return Boolean(current.value);\n    case 'number':\n      return +current.value;\n    case 'null':\n      return null;\n    case 'undefined':\n      return undefined;\n    case 'string':\n      return current.value;\n    default:\n      return 'Data type block failed';\n  }\n}\n\n// Send result back to chrome extension\nfunction sendResult(messageObject) {\n  window.postMessage({ type: 'test-result', data: messageObject}, \"*\"); \n}\n\n// Add assert is called from inject.js whenever an assertion message is recieved from the chrome extension\nfunction addAssert(freshAssert) {\n  // assertBundle is the eventual assertion block that we will be adding\n  let assertBundle = {};\n  assertBundle.asserts = [];\n  assertBundle.name = freshAssert.name; \n\n  // This is a flag to determine whether we have added an action yet on this assertion block\n  // We want to have the ability to see if a specific event happens more than once so we only want to have one spy set up at a time\n  let actionAdded = false; \n  \n  // Loop through our fresh assert bundle so that we can add it to our current asserts\n  freshAssert.asserts.forEach(curr => {\n    // 'actions' require a special logic and need to be reconstructed before inserting\n    if (curr.type === 'action') {\n        // base info for every action\n        let newAssert = {};\n        newAssert.assertID = curr.assertID; \n        newAssert.loc = curr.loc;\n        newAssert.type = 'action';\n        newAssert.event = curr.event;\n        newAssert.inputValue = curr.inputValue; \n\n      // This is how we will handle our first action in the assertion bundle\n      // For this one, we will add a spy  \n      if (!actionAdded) {\n        let spy = sinon.spy();\n        let currNode = getNode(curr.loc)\n        currNode.addEventListener(curr.event, spy);\n        newAssert.spy = spy; \n        newAssert.added = true;\n\n        // Here we set our flag so that we only add one spy to this bundle at this time\n        actionAdded = true;\n        if (curr.event === 'keypress') {\n            newAssert.lastInput = '';\n           currNode.addEventListener(curr.event, () => newAssert.lastInput = currNode.value);\n        }\n      } else {\n        // Any actions other than the first will get no spy and have the added property be false\n        newAssert.added = false; \n      }\n\n      // Here we add our newly made action assert to the bundle  \n    assertBundle.asserts.push(newAssert); \n    } else {\n  \n      // We just pass in an evaluation assert as is  \n      assertBundle.asserts.push(curr);\n    }\n  });\n\n  // Grab our new bundle and add it our current assert queue\n  currentAsserts.push(assertBundle);\n  checkAssert();\n}\n\n// Deletes an assertion block based on the name given\nfunction deleteBlock(name) {\n  for (let i = 0; i < currentAsserts.length; i++) {\n    if (currentAsserts[i].name === name) {\n      currentAsserts.splice(i, 1);\n      break; \n    }\n  }\n}\n\nmodule.exports = {\n  checkAssert,\n  addAssert,\n  deleteBlock,\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}