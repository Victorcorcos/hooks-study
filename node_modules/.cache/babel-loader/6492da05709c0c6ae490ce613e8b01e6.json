{"ast":null,"code":"\"use strict\";\n\nvar getPropertyDescriptor = require(\"./get-property-descriptor\");\n\nvar valueToString = require(\"./value-to-string\");\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isFunction(obj) {\n  return typeof obj === \"function\" || !!(obj && obj.constructor && obj.call && obj.apply);\n}\n\nfunction mirrorProperties(target, source) {\n  for (var prop in source) {\n    if (!hasOwn.call(target, prop)) {\n      target[prop] = source[prop];\n    }\n  }\n} // Cheap way to detect if we have ES5 support.\n\n\nvar hasES5Support = (\"keys\" in Object);\n\nmodule.exports = function wrapMethod(object, property, method) {\n  if (!object) {\n    throw new TypeError(\"Should wrap property of object\");\n  }\n\n  if (typeof method !== \"function\" && typeof method !== \"object\") {\n    throw new TypeError(\"Method wrapper should be a function or a property descriptor\");\n  }\n\n  function checkWrappedMethod(wrappedMethod) {\n    var error;\n\n    if (!isFunction(wrappedMethod)) {\n      error = new TypeError(\"Attempted to wrap \" + typeof wrappedMethod + \" property \" + valueToString(property) + \" as function\");\n    } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n      error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already wrapped\");\n    } else if (wrappedMethod.calledBefore) {\n      var verb = wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n      error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already \" + verb);\n    }\n\n    if (error) {\n      if (wrappedMethod && wrappedMethod.stackTrace) {\n        error.stack += \"\\n--------------\\n\" + wrappedMethod.stackTrace;\n      }\n\n      throw error;\n    }\n  }\n\n  var error, wrappedMethod, i;\n\n  function simplePropertyAssignment() {\n    wrappedMethod = object[property];\n    checkWrappedMethod(wrappedMethod);\n    object[property] = method;\n    method.displayName = property;\n  } // Firefox has a problem when using hasOwn.call on objects from other frames.\n\n\n  var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);\n\n  if (hasES5Support) {\n    var methodDesc = typeof method === \"function\" ? {\n      value: method\n    } : method;\n    var wrappedMethodDesc = getPropertyDescriptor(object, property);\n\n    if (!wrappedMethodDesc) {\n      error = new TypeError(\"Attempted to wrap \" + typeof wrappedMethod + \" property \" + property + \" as function\");\n    } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {\n      error = new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n    }\n\n    if (error) {\n      if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {\n        error.stack += \"\\n--------------\\n\" + wrappedMethodDesc.stackTrace;\n      }\n\n      throw error;\n    }\n\n    var types = Object.keys(methodDesc);\n\n    for (i = 0; i < types.length; i++) {\n      wrappedMethod = wrappedMethodDesc[types[i]];\n      checkWrappedMethod(wrappedMethod);\n    }\n\n    mirrorProperties(methodDesc, wrappedMethodDesc);\n\n    for (i = 0; i < types.length; i++) {\n      mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n    }\n\n    Object.defineProperty(object, property, methodDesc); // catch failing assignment\n    // this is the converse of the check in `.restore` below\n\n    if (typeof method === \"function\" && object[property] !== method) {\n      // correct any wrongdoings caused by the defineProperty call above,\n      // such as adding new items (if object was a Storage object)\n      delete object[property];\n      simplePropertyAssignment();\n    }\n  } else {\n    simplePropertyAssignment();\n  }\n\n  method.displayName = property; // Set up a stack trace which can be used later to find what line of\n  // code the original method was created on.\n\n  method.stackTrace = new Error(\"Stack Trace for original\").stack;\n\n  method.restore = function () {\n    // For prototype properties try to reset by delete first.\n    // If this fails (ex: localStorage on mobile safari) then force a reset\n    // via direct assignment.\n    if (!owned) {\n      // In some cases `delete` may throw an error\n      try {\n        delete object[property];\n      } catch (e) {} // eslint-disable-line no-empty\n      // For native code functions `delete` fails without throwing an error\n      // on Chrome < 43, PhantomJS, etc.\n\n    } else if (hasES5Support) {\n      Object.defineProperty(object, property, wrappedMethodDesc);\n    }\n\n    if (hasES5Support) {\n      var descriptor = getPropertyDescriptor(object, property);\n\n      if (descriptor && descriptor.value === method) {\n        object[property] = wrappedMethod;\n      }\n    } else {\n      // Use strict equality comparison to check failures then force a reset\n      // via direct assignment.\n      if (object[property] === method) {\n        object[property] = wrappedMethod;\n      }\n    }\n  };\n\n  method.wrappedMethod = wrappedMethod;\n  method.restore.sinon = true;\n\n  if (!hasES5Support) {\n    mirrorProperties(method, wrappedMethod);\n  }\n\n  return method;\n};","map":{"version":3,"names":["getPropertyDescriptor","require","valueToString","hasOwn","Object","prototype","hasOwnProperty","isFunction","obj","constructor","call","apply","mirrorProperties","target","source","prop","hasES5Support","module","exports","wrapMethod","object","property","method","TypeError","checkWrappedMethod","wrappedMethod","error","restore","sinon","calledBefore","verb","returns","stackTrace","stack","i","simplePropertyAssignment","displayName","owned","methodDesc","value","wrappedMethodDesc","types","keys","length","defineProperty","Error","e","descriptor"],"sources":["/Users/victorcosta/Desktop/repositories/react-project/hooks-study/node_modules/sinon/lib/sinon/util/core/wrap-method.js"],"sourcesContent":["\"use strict\";\n\nvar getPropertyDescriptor = require(\"./get-property-descriptor\");\nvar valueToString = require(\"./value-to-string\");\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction isFunction(obj) {\n    return typeof obj === \"function\" || !!(obj && obj.constructor && obj.call && obj.apply);\n}\n\nfunction mirrorProperties(target, source) {\n    for (var prop in source) {\n        if (!hasOwn.call(target, prop)) {\n            target[prop] = source[prop];\n        }\n    }\n}\n\n// Cheap way to detect if we have ES5 support.\nvar hasES5Support = \"keys\" in Object;\n\nmodule.exports = function wrapMethod(object, property, method) {\n    if (!object) {\n        throw new TypeError(\"Should wrap property of object\");\n    }\n\n    if (typeof method !== \"function\" && typeof method !== \"object\") {\n        throw new TypeError(\"Method wrapper should be a function or a property descriptor\");\n    }\n\n    function checkWrappedMethod(wrappedMethod) {\n        var error;\n\n        if (!isFunction(wrappedMethod)) {\n            error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                valueToString(property) + \" as function\");\n        } else if (wrappedMethod.restore && wrappedMethod.restore.sinon) {\n            error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already wrapped\");\n        } else if (wrappedMethod.calledBefore) {\n            var verb = wrappedMethod.returns ? \"stubbed\" : \"spied on\";\n            error = new TypeError(\"Attempted to wrap \" + valueToString(property) + \" which is already \" + verb);\n        }\n\n        if (error) {\n            if (wrappedMethod && wrappedMethod.stackTrace) {\n                error.stack += \"\\n--------------\\n\" + wrappedMethod.stackTrace;\n            }\n            throw error;\n        }\n    }\n\n    var error, wrappedMethod, i;\n\n    function simplePropertyAssignment() {\n        wrappedMethod = object[property];\n        checkWrappedMethod(wrappedMethod);\n        object[property] = method;\n        method.displayName = property;\n    }\n\n    // Firefox has a problem when using hasOwn.call on objects from other frames.\n    var owned = object.hasOwnProperty ? object.hasOwnProperty(property) : hasOwn.call(object, property);\n\n    if (hasES5Support) {\n        var methodDesc = (typeof method === \"function\") ? {value: method} : method;\n        var wrappedMethodDesc = getPropertyDescriptor(object, property);\n\n        if (!wrappedMethodDesc) {\n            error = new TypeError(\"Attempted to wrap \" + (typeof wrappedMethod) + \" property \" +\n                                property + \" as function\");\n        } else if (wrappedMethodDesc.restore && wrappedMethodDesc.restore.sinon) {\n            error = new TypeError(\"Attempted to wrap \" + property + \" which is already wrapped\");\n        }\n        if (error) {\n            if (wrappedMethodDesc && wrappedMethodDesc.stackTrace) {\n                error.stack += \"\\n--------------\\n\" + wrappedMethodDesc.stackTrace;\n            }\n            throw error;\n        }\n\n        var types = Object.keys(methodDesc);\n        for (i = 0; i < types.length; i++) {\n            wrappedMethod = wrappedMethodDesc[types[i]];\n            checkWrappedMethod(wrappedMethod);\n        }\n\n        mirrorProperties(methodDesc, wrappedMethodDesc);\n        for (i = 0; i < types.length; i++) {\n            mirrorProperties(methodDesc[types[i]], wrappedMethodDesc[types[i]]);\n        }\n        Object.defineProperty(object, property, methodDesc);\n\n        // catch failing assignment\n        // this is the converse of the check in `.restore` below\n        if ( typeof method === \"function\" && object[property] !== method ) {\n            // correct any wrongdoings caused by the defineProperty call above,\n            // such as adding new items (if object was a Storage object)\n            delete object[property];\n            simplePropertyAssignment();\n        }\n    } else {\n        simplePropertyAssignment();\n    }\n\n    method.displayName = property;\n\n    // Set up a stack trace which can be used later to find what line of\n    // code the original method was created on.\n    method.stackTrace = (new Error(\"Stack Trace for original\")).stack;\n\n    method.restore = function () {\n        // For prototype properties try to reset by delete first.\n        // If this fails (ex: localStorage on mobile safari) then force a reset\n        // via direct assignment.\n        if (!owned) {\n            // In some cases `delete` may throw an error\n            try {\n                delete object[property];\n            } catch (e) {} // eslint-disable-line no-empty\n            // For native code functions `delete` fails without throwing an error\n            // on Chrome < 43, PhantomJS, etc.\n        } else if (hasES5Support) {\n            Object.defineProperty(object, property, wrappedMethodDesc);\n        }\n\n        if (hasES5Support) {\n            var descriptor = getPropertyDescriptor(object, property);\n            if (descriptor && descriptor.value === method) {\n                object[property] = wrappedMethod;\n            }\n        }\n        else {\n        // Use strict equality comparison to check failures then force a reset\n        // via direct assignment.\n            if (object[property] === method) {\n                object[property] = wrappedMethod;\n            }\n        }\n    };\n\n    method.wrappedMethod = wrappedMethod;\n\n    method.restore.sinon = true;\n\n    if (!hasES5Support) {\n        mirrorProperties(method, wrappedMethod);\n    }\n\n    return method;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}